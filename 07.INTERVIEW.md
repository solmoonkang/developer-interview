# 07. INTERVIEW

- [equals()와 hashCode() 메소드의 차이점](#equals와-hashcode-메소드의-차이점은-무엇일까요?)
- [StringBuilder와 StringBuffer의 차이점](#stringbuilder와-stringbuffer의-차이는-무엇일까요?)
- [System.out.println 메소드를 현업에서 쓰지 말라고 하는 이유](#systemoutprintln-메소드를-현업에서-쓰지-말라고-하는-이유가-무엇일까요?)
- [ArrayList의 내부 구현](#arraylist는-내부적으로-어떻게-구현되어있을까요?)
- [스레드를 사용하는 이유](#스레드는-왜-써야하는-것일까요?)
- [동시성 문제](#0이-들어있는-변수에-10개의-스레드가-동시에-접근해서--연산을-하면-우리-예상과-다르게-10이-나오지-않습니다-왜-그럴까요?)
- [동시성 관련 예약어](#자바에서-동시성과-관련된-예약어를-모두-말씀해주세요)
- [Blocking IO와 Non-Blocking IO의 차이](#blocking-io와-non-blocking-io의-차이를-말씀해주세요)
- [Serializable 란](#serializable은-무엇일까요?)

<br>

<details>
<summary style="font-size: 1.5em; font-weight: bold;">equals( )와 hashCode( ) 메소드의 차이점은 무엇일까요?</summary>

### equals( ) 메서드와 hashCode( ) 메서드
**equals 메서드**는 두 객체의 `동등성`을 비교하는 메서드이다. 즉, 두 객체가 같은 내용을 가지고 있는지를 판단한다. 기본적으로 자바의 Object 클래스에서 제공되는 equals 메서드는 객체의 메모리 주소를 비교하여 동일성을 검사한다.
하지만, 일반적으로는 이 메서드를 오버라이드하여 객체의 필드 값을 기반으로 비교하도록 구현한다.

**hashCode 메서드**는 객체의 `동일성`을 기반으로 해시 코드를 반환하는 메서드이다. 이 해시 코드는 객체를 해시 기반의 컬렉션(EX. HashMap)에서 효율적으로 저장하고 검색할 수 있도록 도와준다.
기본적으로 hashCode 메서드도 객체의 메모리 주소를 기반으로 해시 코드를 생성하지만, 오버라이드하여 객체의 필드 값을 기반으로 해시 코드를 생성할 수 있다.

### equals( ) 메서드와 hashCode( ) 메서드의 차이점
- **동등성(`equals`)**: equals( ) 메서드는 두 객체가 '동등한지' 즉, 같은 내용을 가지고 있는지를 비교한다. 기본적으로 Object 클래스의 equals( ) 메서드는 참조(메모리 주소)를 비교하지만, 이 메서드를 오버라이드하여 객체의 필드 값을 기반으로 비교할 수 있다.
- **동일성(`hashCode`)**: hashCode( ) 메서드는 객체의 '동일성'을 기준으로 해시 코드를 생성한다. 기본적으로는 객체의 메모리 주소를 기반으로 해시 코드를 반환하지만, 이 메서드도 오버라이드할 수 있어서 특정 필드 값을 기반으로 해시 코드를 정의할 수 있다. 해시 기반의 컬렉션에서 객체를 효율적으로 관리하기 위해 중요하다.

<br>

<details>
<summary style="font-size: 1.2em; font-weight: bold;">❓ 잘못 답변할 수 있는 케이스</summary>

#### "hashCode"는 객체의 메모리 주소를 리턴한다고 하는데, 그럼 우리가 "hashCode"를 오버라이드 했을 때에도 메모리 주소를 리턴할 수 있을까요? 자바에서는 개발자가 직접 메모리에 접근할 수 있나요?
> hashCode 메서드를 오버라이드할 경우 개발자가 원하는 방식으로 해시 코드를 정의할 수 있기 때문이다. 자바에서는 개발자가 직접 메모리에 접근할 수 없으므로, hashCode 메서드는 객체의 필드 값을 기반으로 해시 코드를 생성하도록 구현할 수 있다. 따라서 해시 코드는 메모리 주소와는 무관한 값이 될 수 있다.

</details>

<details>
<summary style="font-size: 1.2em; font-weight: bold;">❓ 꼬리질문</summary>

#### "hashCode"를 잘못 오버라이딩하면 "HashMap" 등 hash 콜렉션의 성능이 떨어질 수가 있는데, 어떤 케이스일 때 그럴 수 있나요?
> hashCode 메서드를 잘못 오버라이드하면 HashMap과 같은 해시 기반 컬렉션의 성능이 저하될 수 있다. 예를 들어, 두 객체가 equals 메서드로 동등하더라도 서로 다른 해시 코드를 반환하는 경우, HashMap은 이 객체들을 서로 다른 위치에 저장하게 된다. 이로 인해 HashMap의 성능이 떨어지며, 충돌이 많이 발생하여 LinkedList 형태로 저장되거나 Red-Black Tree로 변환될 수 있다.

#### "HashMap"은 내부적으로 어떻게 구현되어 있길래 빨리 값을 탐색할 수 있나요?
> HashMap은 내부적으로 배열과 LinkedList 또는 Red-Black Tree를 사용하여 구현되어 있다. 기본적으로 배열의 각 인덱스는 해시 코드에 따라 객체가 저장되는 버킷을 의미한다. 만약 해시 코드가 충돌하면, 해당 인덱스에 LinkedList가 생성되어 여러 객체가 저장된다. 충돌이 많이 발생할 경우, LinkedList가 길어지면서 성능이 저하되므로, Java 8부터는 LinkedList가 일정 길이를 넘으면 Red-Black Tree로 변환되어 성능을 개선한다.

#### 기존 "HashMap"의 시간 복잡도는 얼마이고, "hashCode"를 잘못 오버라이딩 했을 때의 시간복잡도는 얼마일까요?
> 기존 HashMap의 평균적인 검색, 삽입, 삭제 시간 복잡도는 O(1)이다. 하지만 해시 충돌이 많아져서 LinkedList가 길어지거나 Red-Black Tree로 변환될 경우, 최악의 경우 시간 복잡도는 O(n)까지 증가할 수 있다. 잘못 오버라이드된 hashCode로 인해 충돌이 많아지면, 이러한 최악의 상황이 발생할 수 있다. 따라서 hashCode 메서드를 적절히 오버라이드하는 것이 중요하다.

</details>
</details>

<br>

<details>
<summary style="font-size: 1.5em; font-weight: bold;">StringBuilder와 StringBuffer의 차이는 무엇일까요?</summary>

### StringBuilder와 StringBuffer의 차이점
StringBuilder와 StringBuffer는 Java에서 문자열을 조작하기 위한 클래스로 두 클래스는 비슷한 기능을 제공하지만, 중요한 차이점이 있다.
- **1. 동기화(Synchronization)**: 
  - `StringBuffer`: 동기화된 클래스로 여러 스레드가 동시에 접근할 때 안전하게 사용할 수 있도록 설계되었다. 그 결과, 멀티스레드 환경에서 안전하지만 성능이 저하될 수 있다.
  - `StringBuilder`: 동기화되지 않은 클래스로 멀티스레드 환경에서는 안전하지는 않지만, 단일 스레드에서 사용할 때는 더 빠르다.
- **2. 성능**: 
  - `StringBuffer`는 동기화로 인해 성능이 떨어지므로, 단일 스레드 환경에서는 `StringBuilder`가 더 빠르다.
  - `StringBuilder`는 동기화가 없기 때문에 더 빠른 성능을 제공한다.
- **3. 용도**: 
  - `StringBuffer`는 멀티스레드 환경에서 문자열을 안전하게 조작해야 할 때 사용한다.
  - `StringBuilder`는 단일 스레드 환경에서 문자열을 조작할 때 주로 사용한다.

<details>
<summary style="font-size: 1.2em; font-weight: bold;">❓ 꼬리 질문</summary>

#### 왜 동기화(Synchronized)가 걸려있으면 느린걸까요?
> 동기화가 걸리면, 특정 스레드가 공유 자원에 접근할 때 다른 스레드가 동시에 접근하지 못하도록 막는다. 이로 인해 스레드 간의 경쟁 상태(Race Condition)를 방지할 수 있지만, 다음과 같은 이유로 성능이 저하된다.
> - **대기 시간**: 한 스레드가 동기화된 블록에 들어가면 다른 스레드는 그 블록이 해제될 때까지 기다려야 한다. 이로 인해 대기 시간이 발생한다.
> - **오버헤드**: 동기화는 추가적인 오버헤드를 발생시킨다. 스레드가 동기화된 메서드에 들어오고 나갈 때마다 상태를 체크해야 하므로 성능이 저하된다.

#### 싱글 스레드로 접근한다는 가정하에선 `StringBuilder`와 `StringBuffer`의 성능이 똑같을까요?
> 아니다. 이 둘의 성능은 다르다. `StringBuilder`는 동기화가 없기 때문에 단일 스레드 환경에서 더 빠르다. 반면, `StringBuffer`는 동기화로 인해 추가적인 오버헤드가 발생하므로 성능이 떨어진다. 따라서 단일 스레드 환경에서는 `StringBuilder`가 더 효율적이다. 

</details>

<details>
<summary style="font-size: 1.2em; font-weight: bold;">❓ 함정 질문</summary>

#### `synchronized` 키워드를 달면 내부적으로 어떤 일이 벌어지는지 동작 원리에 대해 알아보자.
> `synchronized` 키워드는 메서드나 블록에 적용되어 해당 코드 영역에 대한 접근을 제어한다.
> - **모니터 락(Monitor Lock)**: `synchronized`가 적용된 메서드나 블록에 접근하려는 스레드는 먼저 해당 객체의 모니터 락을 획득해야 한다. 이 락은 객체에 대한 독점적인 접근을 보장한다.
> - **대기 및 경쟁**: 한 스레드가 락을 획득하면 다른 스레드는 그 락이 해제될 때까지 대기해야 한다. 이로 인해 여러 스레드 간의 경쟁이 발생할 수 있다.
> - **스레드 안정성**: `synchronized`를 통해 메서드가 동시에 실행되지 않도록 보장하므로, 데이터의 일관성을 유지할 수 있다. 

이러한 동작 원리 때문에 `StringBuffer`는 멀티스레드 환경에서 안전하게 사용할 수 있지만, 성능이 떨어지는 단점이 있다.

</details>
</details>

<br>

<details>
<summary style="font-size: 1.5em; font-weight: bold;">System.out.println 메소드를 현업에서 쓰지 말라고 하는 이유가 무엇일까요?</summary>

### System.out.println 메서드를 현업에서 절대 쓰지 말라고 하는 이유
- **1. 성능 문제**: 
  - `System.out.println`은 콘솔에 출력을 수행하는 메서드로, 성능이 매우 저조하다. 이 메서드는 I/O 작업이 포함되므로, 출력이 발생할 때마다 시스템이 출력을 처리하는 데 시간이 걸린다.
  - 특히 대량의 데이터를 출력할 때, 이 메서드는 병목 현상을 일으킬 수 있다.
- **2. Blocking I/O**: 
  - `System.out.println`은 블로킹 I/O를 사용한다. 즉, 출력 작업이 완료될 때까지 호출한 스레드는 대기하게 된다. 이로 인해 다른 작업이 지연될 수 있다.
- **3. 스레드 안전성**:
  - `System.out.println`은 기본적으로 동기화되지 않아서 여러 스레드가 동시에 접근할 경우 출력 결과가 섞이는 경우가 발생할 수 있다. 이는 디버깅과 로깅에 문제를 일으킬 수 있다.

<details>
<summary style="font-size: 1.2em; font-weight: bold;">❓ 꼬리 질문</summary>

#### 성능 저하의 이유
> - **I/O 작업의 비용**: 콘솔 출력은 메모리 내에서 데이터를 처리하는 것보다 훨씬 느리다. I/O 작업이 발생할 때마다 커널과의 상호작용이 필요하기 때문에 성능이 저하된다.
> - **스레드 대기**: 블로킹 I/O는 스레드가 대기 상태로 전환되게 하여 CPU 자원이 효율적으로 사용되지 못하게 한다.

#### `synchronized` 키워드는 왜 현업에서 큰 성능 저하를 일으킬 수 있을까요?
> - **모니터 락 경합**: `synchronized` 키워드는 특정 코드 블록에 대한 접근을 제어한다. 여러 스레드가 동시에 해당 블록에 접근하려고 할 경우, 락을 획득하기 위해 대기해야 하므로 성능이 저하된다.
> - **대기 시간**: 락을 획득하기 위해 대기하는 동안 스레드는 CPU를 사용하지 않으므로, 전체적인 처리 성능이 저하된다.

#### Blacking I/O는 왜 성능을 저하시킬 수 있을까요?
> - **대기 상태**: 블로킹 I/O는 작업이 완료될 때까지 스레드를 대기 상태로 전환한다. 이로 인해 다른 작업이 수행되지 못하고, 시스템의 자원이 비효율적으로 사용된다.
> - **스레드 리소스 낭비**: 대기하는 스레드가 시스템 자원을 점유하게 되므로, 다른 스레드가 CPU를 사용하기 어렵게 만든다.

#### `synchronized`와 Blocking I/O가 만나면 어떻게 성능 하락을 초래할 수 있을까요?
> - **락 대기와 블로킹**: `synchronized` 블록 내에서 블로킹 I/O 작업이 발생하면, 해당 블로킹 I/O가 완료될 때까지 락을 획득한 스레드가 대기하게 된다. 다른 스레드가 락을 획득하려고 대기하는 동안, 블로킹 I/O가 진행 중인 스레드는 CPU를 사용하지 않게 된다.
> - **CPU 사용률 저하**: 이로 인해 CPU 사용률이 낮아지고, 전체 애플리케이션의 응답성이 저하될 수 있다.

</details>

### 시뮬레이션: 스레드 동작 및 CPU 사용률
1. 스레드 1이 `synchronized` 블록에 진입하고, 블로킹 I/O 작업을 수행한다고 가정한다.
2. 스레드 1이 블로킹 I/O 작업을 수행하는 동안, 스레드 2는 `synchronized` 블록에 접근하려고 대기한다.
3. 스레드 1이 블로킹 I/O로 인해 대기 상태에 있을 때, 스레드 2는 락을 획득하지 못하므로 대기한다.
4. 이로 인해 CPU 사용률이 낮아지고, 응답 시간은 증가한다.

결과적으로, `synchronized`와 블로킹 I/O가 결합되면 시스템의 성능이 크게 저하되고, 스레드 간의 경쟁 상태와 대기 상태가 발생하여 CPU 자원이 비효율적으로 사용된다.

</details>

<br>

<details>
<summary style="font-size: 1.5em; font-weight: bold;">ArrayList 는 내부적으로 어떻게 구현되어있을까요?</summary>

### ArrayList의 내부 구현
ArrayList는 Java의 List 인터페이스를 구현한 클래스 중 하나로, 내부적으로 동적 배열을 사용하여 요소를 저장한다.

- **1. 배열 기반**:
  - ArrayList는 객체를 저장하기 위해 배열을 사용한다. 초기에는 일정 크기의 배열을 생성하고, 요소가 추가될 때 이 배열에 저장한다.
- **2. 크기 조정**: 
  - 배열의 크기가 꽉 차면, ArrayList는 새로운 배열을 생성하고 기존 배열의 내용을 새로운 배열로 복사한다. 일반적으로 새로운 배열의 크기는 기존 배열의 1.2배로 설정된다.
  - 이 방법을 통해 ArrayList는 가변적인 크기를 지원하며, 배열의 크기가 동적으로 조정된다.
- **3. 성능**:
  - 요소를 추가할 때 배열이 꽉 차면 복사가 필요하므로, 이 과정에서 O(n)의 시간 복잡도가 발생한다.
  - 그러나 평균적으로 요소를 추가하는 데 O(1)의 성능을 가진다.
- **4. 기본 크기**:
  - ArrayList는 기본 생성자를 사용하여 생성할 경우, 초기 크기로 10개의 요소를 저장할 수 있는 배열을 만든다.
  - 만약, 생성 시 특정 크기를 지정하면 해당 크기로 초기 배열이 생성된다.

<details>
<summary style="font-size: 1.2em; font-weight: bold;">❓ 꼬리 질문</summary>

#### 배열로 구현되어 있다면 분명 크기가 꽉 차면 일반 배열처럼 예외가 발생할탠데 ArrayList는 어떻게 무한히 데이터를 받을 수 있을까요?
> 배열이 꽉 차면 예외가 발생하는 것이 아니라, ArrayList가 새로운 배열을 생성하고 기존 데이터를 복사하여 크기를 조정한다. 따라서 사용자는 ArrayList의 크기 제한을 걱정할 필요가 없다.

</details>

<details>
<summary style="font-size: 1.2em; font-weight: bold;">🔍 IDE를 이용한 내부 구현</summary>

Java의 ArrayList 클래스는 `java.util` 패키지에 포함되어 있으며, 해당 클래스의 소스 코드를 IDE에서 확인할 수 있다. 소스 코드를 통해 실제 배열 사용 및 크기 조정 로직을 직접 확인할 수 있다.
예를 들어, Java 8 기준의 ArrayList 내부 구현의 일부는 다음과 같다.

```java
public class ArrayList<E> extends AbstractList<E> implements List<E>, RandomAccess, Cloneable, Serializable {
    private Object[] elementData; // 저장할 배열
    private int size; // 현재 저장된 요소의 개수

    public ArrayList() {
        this.elementData = new Object[10]; // 초기 크기 10
    }

    public boolean add(E e) {
        ensureCapacity(); // 크기 조정 메서드 호출
        elementData[size++] = e; // 요소 추가
        return true;
    }

    private void ensureCapacity() {
        if (size == elementData.length) {
            int newCapacity = size + (size >> 1); // 1.5배 증가
            elementData = Arrays.copyOf(elementData, newCapacity);
        }
    }
}
```

</details>
</details>

<br>

<details>
<summary style="font-size: 1.5em; font-weight: bold;">스레드는 왜 써야하는 것일까요?</summary>

### 스레드를 사용하는 이유
스레드는 여러 작업을 동시에 수행할 수 있게 해주는 경량 프로세스이다. 스레드를 사용하는 주요 이유는 다음과 같다.

- **1. 동시성**: 
  - 스레드를 사용하면 여러 작업을 동시에 처리할 수 있다.
  - 예를 들어, 사용자 인터페이스를 유지하면서 백그라운드에서 데이터 처리 작업을 수행할 수 있다.
- **2. 자원 효율성**:
  - 스레드는 프로세스보다 메모리 자원을 덜 소모한다. 여러 스레드는 같은 프로세스의 메모리 공간을 공유하므로, 메모리 사용이 효율적이다.
- **3. 응답성 향상**:
  - 스레드를 사용하여 응답성을 높일 수 있다.
  - 예를 들어, 웹 서버는 여러 클라이언트 요청을 동시에 처리하여 사용자 경험을 개선할 수 있다.

<details>
<summary style="font-size: 1.2em; font-weight: bold;">❓ 꼬리 질문</summary>

#### 스레드를 사용하면 동시에 여러 일을 처리할 수 있으니 한 1만 개 정도 띄우면 좋지 않을까요?
> 이론적으로는 좋지만, 실제로는 그렇지 않다. 스레드를 너무 많이 생성하면 다음과 같은 문제점이 발생한다.
> - **1. 자원 소모**: 각 스레드는 스택 메모리와 같은 자원을 소모하므로, 너무 많은 스레드를 생성하면 메모리 부족 문제가 발생할 수 있다.
> - **2. 성능 저하**: 스레드가 많아지면, CPU가 여러 스레드 간의 작업을 전환해야 하므로 성능이 저하된다. 이 과정에서 발생하는 비용은 `컨텍스트 스위칭`으로 인해 발생한다.

#### 스레드를 사용하는 데에 어떤 비용이 들까요?
> - **1. 메모리**: 
>   - 각 스레드는 스택 메모리를 포함하여 고유의 메모리 공간을 할당받는다. 
>   - 이 메모리 양은 JVM의 설정에 따라 다르지만, 일반적으로 1MB에서 2MB 정도이다. 따라서 1만 개의 스레드를 생성한다면, 최소 10GB에서 20GB의 메모리가 필요할 수 있다.
> - **2. 컨텍스트 스위칭**:
>   - 스레드 간에 작업을 전환할 때 발생하는 비용이다. 컨텍스트 스위칭은 CPU가 현재 실행 중인 스레드의 상태 정보를 저장하고, 다음 스레드의 상태 정보를 로드하는 과정이다. 
>   - 이는 CPU 사이클 단위로 비용이 발생하며, 일반적으로 10~100 마이크로초(μs)정도 소요된다. CPU가 1초 동안 1억 사이클을 처리할 수 있는 경우, 컨텍스트 스위칭은 상대적으로 큰 비용이 될 수 있다.

#### 컨텍스트 스위칭은 비용이 얼마나 들까요?
> 컨텍스트 스위칭의 비용은 CPU 아키텍처와 운영체제에 따라 다르지만, 일반적으로 10μs에서 100μs 정도 소요된다. 이를 CPU 사이클로 환산하면 다음과 같다.
> - 1초는 1,000,000 μs이므로, 1초 동안 1억 사이클을 처리하는 CPU에서 10μs의 컨텍스트 스위칭은 약 1,000 사이클의 비용이 된다.
> - 반면, 100μs의 경우 약 10,000 사이클의 비용이 발생할 수 있다.

이러한 비용은 스레드 수가 많아질수록 더 심각해지며, 결과적으로 시스템 성능을 저하시킬 수 있다.

</details>
</details>

<br>

<details>
<summary style="font-size: 1.5em; font-weight: bold;">0이 들어있는 변수에 10개의 스레드가 동시에 접근해서 ++ 연산을 하면 우리 예상과 다르게 10이 나오지 않습니다. 왜 그럴까요?</summary>

### 동시성 문제의 원인
0이 들어있는 변수에 10개의 스레드가 동시에 접근하여 ++ 연산을 수행할 때, 예상과 다르게 10이 나오지 않는 이유는 `경쟁 조건(Race Condition)` 때문이다.

<details>
<summary style="font-size: 1.2em; font-weight: bold;">❓ 꼬리 질문</summary>

#### ++ 연산은 구체적으로 어떤 행위들로 이루어져 있을까요?
10개의 스레드가 동시에 같은 변수에 접근하여 ++ 연산을 수행할 때, 각 세르데는 다음과 같은 세 단계를 거친다:

> 1. 메모리에서 해당 값을 가져온다.
> 2. 해당 값에 1을 더한다.
> 3. 메모리에 더한 값을 덮어씌운다.

이 과정에서 스레드들이 동시에 실행되기 때문에, 한 스레드가 값을 가져온 상태에서 다른 스레드가 값을 수정할 수 있다.
예를 들어, 스레드 A와 스레드 B가 동시에 0을 읽어온 뒤 각각 1을 더해서 다시 메모리에 저장하게 되면, 최종적으로 두 스레드 모두 1을 저장하게 된다. 이런 식으로 여러 스레드가 동시에 접근하면, 최종 결과가 예상한 10이 아니라 더 적은 값이 될 수 있다.

</details>

<details>
<summary style="font-size: 1.2em; font-weight: bold;">❓ 꼬리 질문</summary>

#### 이 문제를 해결하려면 어떻게 해야 할까요?
> 이 문제를 해결하는 방법은 동기화(Synchronization)이다. Java에서는 synchronized 키워드를 사용하여 특정 코드 블록이나 메서드에 대한 접근을 제한할 수 있다. 이를 통해 한 스레드가 해당 메서드를 실행하는 동안 다른 스레드는 대기하게 되어, 각 스레드가 순차적으로 ++ 연산을 수행하게 된다.

예를 들어, 다음과 같은 방식으로 increment( ) 메서드를 동기화할 수 있다: 
```java
public synchronized void increment() {
    count++;
}
```
이렇게 함으로써, 멀티 스레드 환경에서도 예상한 대로 결과가 나오게 할 수 있다.

</details>
</details>

<br>

<details>
<summary style="font-size: 1.5em; font-weight: bold;">자바에서 동시성과 관련된 예약어를 모두 말씀해주세요.</summary>

### 자바의 동시성과 관련된 예약어
1. **synchronized**: `synchronized` 키워드는 메서드 또는 블록에 대해 동기화를 구현하는 데 사용된다. 여러 스레드가 동일한 자원에 접근할 때, `synchronized`를 사용하여 한 번에 하나의 스레드만 접근할 수 있도록 한다.
2. **volatile**: `volatile` 키워드는 변수에 적용되며, 해당 변수가 여러 스레드에서 동시에 접근될 수 있음을 나타낸다. `volatile`로 선언된 변수는 항상 메인 메모리에서 읽고 쓰기 때문에, 스레드 간의 가시성을 보장한다.

<details>
<summary style="font-size: 1.2em; font-weight: bold;">❓ 꼬리 질문</summary>

#### `volatile` 키워드에 대한 설명
> - **가시성 보장**: 
>   - `volatile` 변수는 한 스레드에서 변경된 값을 다른 스레드가 즉시 볼 수 있도록 보장한다.
>   - `volatile`로 선언된 변수는 해당 변수가 메모리에 즉시 반영되고, 다른 스레드가 이 변수를 읽을 때 항상 최신 값을 읽을 수 있다.
>   - 이는 캐시된 값이 아니라 메인 메모리의 값을 읽기 때문이다.

#### `volatile` 키워드의 사용 상황
`volatile` 키워드는 다음과 같은 상황에서 유용하게 사용될 수 있다: 

> - **플래그 변수**:
>   - 여러 스레드가 종료 여부를 확인하는 플래그 변수에 사용될 수 있다.
>   - 예를 들어, 스레드가 실행 중인지 여부를 나타내는 변수에 `volatile`을 사용하면, 한 스레드가 종료 플래그를 변경했을 때 다른 스레드가 즉시 이를 감지할 수 있다.
> - **단순한 상태 관리**: 
>   - 상태를 나타내는 변수 (예를 들어, 설정값, 카운터 등)에 사용되며, 복잡한 동기화가 필요하지 않은 경우에 적합하다.
> - **비교적 낮은 성능 요구**:
>   - 동기화가 필요하지만, 성능 저하를 최소화하려는 경우에도 `volatile`을 사용할 수 있다.

</details>

이처럼 `volatile`은 간단한 동시성 문제를 해결하는 데 유용하지만, 복잡한 상태 관리나 여러 변수의 원자성을 요구하는 경우에는 적합하지 않을 수 있다.

</details>

<br>

<details>
<summary style="font-size: 1.5em; font-weight: bold;">Blocking IO와 Non-Blocking IO 의 차이를 말씀해주세요.</summary>

</details>

<br>

<details>
<summary style="font-size: 1.5em; font-weight: bold;">Serializable 은 무엇일까요?</summary>

</details>
