# 01. JAVA

- [equals()와 hashCode() 메소드](#equals와-hashcode-메소드)
- [StringBuilder와 StringBuffer의 차이](#stringbuilder와-stringbuffer의-차이)
- [System.out.println 메소드를 현업에서 쓰지 말라고 하는 이유](#systemoutprintln-메소드)
- [ArrayList의 내부 구현](#arraylist의-내부-구현)
- [스레드의 필요성](#스레드의-필요성)
- [동시성 문제](#동시성-문제)
- [동시성과 관련된 예약어](#동시성과-관련된-예약어)
- [Blocking IO와 Non-Blocking IO의 차이](#blocking-io와-non-blocking-io의-차이)
- [Serializable](#serializable)

<br>

<details>
<summary style="font-size: 1.5em; font-weight: bold;">equals()와 hashCode() 메소드</summary>

equals와 hashCode 메서드는 자바에서 객체 동등성의 개념을 구현하는 데 중요한 역할을 한다. 왜냐하면 이 메서드들은 객체가 논리적으로 동등한지를 판단하는 기준을 제공하기 때문이다.

- **equals 메서드**: 객체의 동등성 비교를 수행한다. 재정의하지 않으면 객체의 참조(주소)를 비교하게 된다.
- **hashCode 메서드**: 해시 기반의 컬렉션에 객체를 저장할 때 사용되는 해시코드를 제공한다.

> **팁**: equals 메서드를 재정의할 때는 hashCode 메서드도 함께 재정의해야 한다. 이는 equals 메서드에 의해 동등하다고 판단된 객체들이 hashCode 메서드에 의해 동일한 해시코드 값을 가져야 하기 때문이다.

</details>

<br>

<details>
<summary style="font-size: 1.5em; font-weight: bold;">StringBuilder와 StringBuffer의 차이</summary>

StringBuilder & StringBuffer 클래스는 문자열을 연산(추가하거나 변경)할 때 주로 사용하는 자료형이다.

- **StringBuilder**: 문자열 파싱 성능이 가장 우수하지만, 동기화(Synchronization)를 지원하지 않아 멀티 스레드 환경에서 안전하지 않다.
- **StringBuffer**: 동기화(Synchronization)를 지원하여 멀티 스레드 환경에서 안전하다.

> **팁**: JAVA에서 synchronized 키워드는 여러 스레드가 하나의 자원에 접근할 때, 현재 데이터를 사용하는 스레드를 제외한 나머지 스레드가 데이터에 접근할 수 없도록 막는 역할을 수행한다.

</details>

<br>

<details>
<summary style="font-size: 1.5em; font-weight: bold;">System.out.println 메소드를 현업에서 쓰지 말라고 하는 이유</summary>

System.out.println 메서드는 Java 개발할 때 디버깅 용도로 콘솔에 출력하는 메서드 중 하나이다.
> System은 java.lang 패키지의 내장된 최종 클래스며, out은 System 클래스의 정적 멤버 필드로 PrintStream이며, println은 PrintStream 클래스의 메서로 표준 콘솔에 전달된 인자와 줄바꿈을 출력한다.

- **1. 성능 이슈**: 
  - 블로킹 I/O와 멀티스레드에서 LOCK이 발생한다.
  - System.out.println이 끝날 때까지 아무 일을 실행할 수 없고, 대기해야 하기 때문에 성능을 저하시킬 수 있다.
- **2. 로그 레벨 관리의 어려움**: 
  - 로그 레벨을 지정할 수 없기 때문에 디버깅 용도로 사용되는 경우, 어떤 로그 레벨로 출력되는지 확인하기 어렵다.
  - 로그 레벨이 제대로 관리되지 않으면, 프로덕션 환경에서도 불필요한 디버깅 정보가 출력되어 시스템의 안정성과 보안에 문제가 생길 수 있다.
- **3. 유지보수성 저하**: 
  - 출력 메시지가 코드에 하드코딩이 되어 있다면, 이후 메시지를 수정하거나 삭제하는 등의 변경 작업에 어려움이 생길 수 있다.

> **팁**: 운영 시스템에서 System.out.println을 사용하기 보다 로깅 프레임워크(logback OR log4j)를 사용하여 적절한 로그 레벨을 지정하여 출력하는 것이 좋다.

</details>

<br>

<details>
<summary style="font-size: 1.5em; font-weight: bold;">ArrayList의 내부 구현</summary>
여기에 내용을 작성하세요.
</details>

<br>

<details>
<summary style="font-size: 1.5em; font-weight: bold;">스레드의 필요성</summary>

스레드는 프로세스 내에서 실행되는 경량의 실행 단위이다. 하나의 프로세스는 여러 개의 스레드를 가질 수 있으며, 이들은 자원을 공유하면서 동시에 작업을 수행할 수 있다.

- **1. 병렬 처리**: 스레드를 사용하면 여러 작업을 동시에 수행할 수 있다. 이는 CPU의 멀티코어 기능을 활용하여 성능을 극대화할 수 있게 해준다.
- **2. 자원 공유**: 스레드는 같은 프로세스 내에서 메모리 공간을 공유하므로, 스레드 간의 데이터 전송이 빠르고 효율적이다. 이로 인해 데이터 공유와 통신이 용이하며, 자원을 절약할 수 있다.
- **3. 응답성 향상**: GUI 애플리케이션에서 스레드를 사용하면 사용자 인터페이스가 블로킹되지 않고, 사용자와의 상호작용을 계속 유지할 수 있다.
- **4. 비동기 작업**: 스레드를 사용하여 비동기적으로 작업을 수행할 수 있다. 이는 작업 완료를 기다리지 않고 다른 작업을 계속 진행할 수 있게 해준다.
- **5. 성능 향상**: CPU 바운드 작업이나 I/O 바운드 작업에서 스레드를 사용하면 성능을 최적화할 수 있다. 특히, I/O 작업은 대기 시간이 길기 때문에 다른 스레드가 실행될 수 있도록 하여 자원을 효율적으로 사용할 수 있다.

> 스레드는 병렬 처리, 자원 공유, 응답성 향상 등 다양한 장점을 제공하여 프로그램의 성능과 효율성을 높이는 데 중요한 역할을 한다. 하지만 스레드 사용 시 동기화 문제, 데드락과 같은 복잡성이 증가할 수 있으므로 적절한 설계가 필요하다.

</details>

<br>

<details>
<summary style="font-size: 1.5em; font-weight: bold;">동시성 문제</summary>
여기에 내용을 작성하세요.
</details>

<br>

<details>
<summary style="font-size: 1.5em; font-weight: bold;">동시성과 관련된 예약어</summary>
여기에 내용을 작성하세요.
</details>

<br>

<details>
<summary style="font-size: 1.5em; font-weight: bold;">Blocking IO와 Non-Blocking IO의 차이</summary>
여기에 내용을 작성하세요.
</details>

<br>

<details>
<summary style="font-size: 1.5em; font-weight: bold;">Serializable</summary>
여기에 내용을 작성하세요.
</details>
