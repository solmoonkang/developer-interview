# 01. JAVA

- [1. 객체지향 프로그래밍의 기본 개념](#1-객체지향-프로그래밍의-기본-개념)
    - [객체지향 프로그래밍의 4가지 특징](#객체지향-프로그래밍의-4가지-특징)
    - [SOLID 5원칙](#solid-5원칙)
    - [객체지향, 절차지향, 함수형 프로그래밍의 차이점](#객체지향-절차지향-함수형-프로그래밍의-차이점)
- [2. Java의 기본 개념](#2-java-기본-개념)
  - [원시형과 참조형의 차이점]()
  - [static 키워드란]()
  - [final 키워드란]()
  - [generic 개념]()
  - [Java Stream 개념]()
  - [Java Lambda 표현식]()
  - [Reflection 개념]()
- [3. Java의 컬렉션 프레임워크](#3)
  - [List, Set, Map 인터페이스]()
  - [ArrayList, HashSet, HashMap 구현체]()
  - [Iterator 사용법]()
- [4. Java의 예외 처리](#4)
  - [Exception의 종류(Checked, Unchecked)]()
  - [try-catch-finally 블록]()
  - [사용자 정의 예외]()
- [5. 멀티스레딩](#5)
  - [스레드의 개념]()
  - [Runnable 인터페이스와 Thread 클래스]()
  - [동기화 및 Lock]()
- [6. Java 메모리 관리](#6)
  - [가비지 컬렉션(Garbage Collection)]()
  - [Heap과 Stack 메모리 구조]()
- [7. JVM, JRE, JDK](#7)
  - [JVM의 역할]()
  - [JRE와 JDK의 차이점]()

---

## 1. 객체지향 프로그래밍의 기본 개념

<details>
<summary style="font-size: 1.5em; font-weight: bold;">객체지향 프로그래밍의 4가지 특징</summary>

### 추상화 (Abstraction)
> 객체들이 공통적으로 필요로 하는 속성이나 동작을 하나로 추출해 내는 작업

즉, 알고는 있지만, 정확하게 표현하기 힘든 것들을 중요한 부분이나 특징점으로 잡아 설명하는 것을 추상화한다고 할 수 있다.
프로그래밍에서 추상화는 클래스를 정의할 때 불필요한 부분들을 생략하고 객체의 속성 중 중요한 것에만 중점을 두어 개략화하는 것을 말한다.

예를 들면, 삼성폰과 아이폰이라는 객체가 있을 때, 이 객체들을 하나로 묶을 때 공통적인 특징을 휴대폰으로 묶어서 이름을 붙이는 것을 추상화하고 할 수 있다.
이처럼 공통된 기능을 휴대폰에서 미리 구현을 하고, 상속을 통해서 공통된 기능을 삼성폰과 아이폰에 이어주면 삼성폰과 아이폰은 각자의 고유기능을 집중적으로 개발할 수 있다.
이럴 경우, 공통된 기능을 다시 정의할 필요가 없어 코드의 중복이 줄어들고, 코드의 재사용성이 용이해지는 장점이 있다.

> 즉, 추상화로 구현을 하면 새로운 객체를 만들 때 클래스의 고유기능만 새로 만들어주고, 공통된 기능은 상속을 통해서 이용이 가능하다.

### 상속 (Inheritance)
> 여러 개체들이 지닌 공통된 특성을 추출하여 하나의 개념이나 법칙으로 성립하는 과정이

예를 들어, 삼성폰과 아이폰은 모두 휴대폰이자 통신기기이며 전자제품이라는 공통적인 속성을 가지고 있다. 이처럼 삼성폰 & 아이폰, 휴대폰, 통신기기, 전자제품은 중복된 속성을 포함하고 있다.
이러한 속성들을 각 클래스마다 개별적으로 정의하기보다는, 공통된 속성들을 하나의 클래스로 묶어 상속을 통해 재사용하는 것이 훨씬 효율적인 프로그래밍 방법이다.

상속을 통해 하위 클래스는 상위 클래스의 변수와 메서드를 물려받아 재사용할 수 있다. 이로 인해 코드의 중복을 줄이고, 유지보수성을 높일 수 있다.

### 다형성 (Polymorphism)
> 프로그래밍에서의 다형성이란 같은 자료형에 여러가지 타입의 데이터를 대입하여 다양한 결과를 얻어낼 수 있는 성질을 의미

비유적으로 표현하자면, 한 명의 남자는 특정 상황에서 여러 가지 역할을 수행한다. 누군가에게는 친구, 자식에게는 아버지, 동아리에서는 리더, 아내에게는 남편, 부모님에게는 자식이 될 수 있다.
이처럼 객체도 상황에 따라 여러가지 형태를 가질 수 있다는 것이 다형성의 핵심이다. 대표적인 예로는 `메서드 오버라이딩`과 `메서드 오버로딩`이 있다.

#### 💡 메서드 오버라이딩 (Overriding)
- 부모 클래스의 메서드를 자식 클래스에서 재정의해서 사용하는 것을 의미한다. 자식 클래스는 부모 클래스의 메서드를 재활용하면서 독자적인 기능을 추가할 수 있다.

#### 💡 메서드 오버로딩 (Overloading)
- 같은 이름의 메서드를 다양한 매개변수 타입과 개수로 정의하는 것을 의미한다. 오버로딩은 메서드 이름을 동일하게 유지하면서도 다양한 상황에서 유연하게 대응할 수 있는 방법을 제공한다.

적절하게 다형성을 활용하면 코드의 재사용성과 유연성을 높이고, 불필요한 코드 중복과 결합도를 낮춰서 유지보수성을 높일 수 있다. 그러나 무분별한 오버로딩은 코드의 동작을 이해하는 데 어려움을 줄 수 있으므로, 적절한 사용이 필요하다.

### 캡슐화 (Encapsultation)
> 객체지향에서의 캡슐화는 데이터와 메서드를 하나의 단위로 묶어 외부에서 접근하지 못하도록 보호하는 개념

예를 들어, 알약은 그 안에 어떤 구성물질이 들어 있는지 알 수 없으며, 내용물은 캡슐을 통해서 안전하게 보호된다. 이처럼 캡슐화는 외부에서 알 필요가 없는 부분을 감춤으로써 대상을 단순화하는 추상화의 한 형태이다.

#### 💡 캡슐화를 해야 하는 이유
- **데이터 보호**:
  - 외부로부터 클래스에 정의된 속성과 기능들을 보호한다.
- **데이터 은닉**:
  - 내부의 동작을 감추고 외부에는 필요한 부분만 노출한다.

캡슐화가 중요한 이유는 불안정한 부분과 안정적인 부분을 분리하여 변경의 영향을 통제할 수 있기 때문이다. 불안정한 부분은 객체 내부로 추상화해서 변경을 최소화하고, 안정적인 부분은 외부에 공개한다. 
이렇게 객체의 외부와 내부를 구분하면 구현 변경의 폭이 넓이지고, 변경의 영향을 효과적으로 관리할 수 있다. 또한, 캡슐화를 통해 코드 작성 이후의 추가 요구사항에도 유연하게 대처할 수 있다.

</details>

<br>

<details>
<summary style="font-size: 1.5em; font-weight: bold;">SOLID 5원칙</summary>

### 객체지향 설계의 5가지 원칙, SOLID

**SOLID**는 `SRP(단일 책임)`, `OCP(개방-폐쇄)`, `LSP(리스코프 치환)`, `ISP(인터페이스 분리)`, `DIP(의존 역전)`로, SOLID 원칙을 지키면 시간이 지나도 변경이 용이하고, 유지보수와 확장이 쉬운 소프트웨어를 개발하는데 도움이 된다.

#### SRP (Single Responsibility Principle): 단일 책임 원칙

`단일 책임 원칙(SRP)`은 하나의 클래스가 오직 하나의 책임만 가져야 한다는 원칙이다. 즉, 클래스는 하나의 기능에 대해 변경이 필요할 때만 수정되어야 하며, 이는 유지보수의 효율성을 높인다.

> - **책임의 정의**: 클래스가 수행하는 기능을 의미한다.
> - **변경 이유**: 클래스의 변경 이유는 단 하나여야 하며, 이를 통해 파급 효과를 최소화할 수 있다.
> - **유지보수 효율성**: 여러 책임을 가진 클래스는 서로 영향을 주어 유지보수가 비효율적이 된다.
> - **응집도와 결합도**: 높은 응집도와 낮은 결합도를 유지해야 하며, 이를 통해 코드의 품질을 높일 수 있다.

예를 들어, 하나의 클래스가 여러 기능을 수행하면, 내부 함수 간의 결합도가 높아져 코드 효율성이 떨어질 수 있다. 따라서 각 클래스는 명확한 책임을 가져야 한다.

#### OCP (Open-Closed Principle): 개방-폐쇄 원칙

`개방-폐쇄 원칙(OCP)`은 소프트웨어 요소가 **확장에는 열려 있으나 변경에는 닫혀 있어야 한다**는 원칙이다. 즉, 기존 코드를 수정하지 않고도 기능을 추가하거나 변경할 수 있도록 설계해야 한다.

> - **기능 수정**: 새로운 클래스를 생성하여 기존 인터페이스를 구현함으로써 기능을 확장할 수 있다.
> - **유지보수 간소화**: 특정 모듈의 기능을 수정할 때, 해당 모듈을 사용하는 모든 모듈을 수정할 필요가 없어 유지보수가 간편해진다.
> - **장점**: OCP를 지키면 유연성, 재사용성, 유지보수성을 극대화할 수 있다.

OCP를 구현하기 위해서는 기존 코드를 변경하지 않고 기능을 수정하거나 추가하기 위해서 `상속(다형성)`과 `추상화(인터페이스)`를 활용해야 한다. 자주 변경되는 부분을 추상화하여 기존 코드의 수정을 최소화하고, 기능 확장을 용이하게 한다.

#### LSP (Liskov Substitution Principle): 리스코프 치환 원칙

`리스코프 치환 원칙(LSP)`은 하위 타입 객체가 상위 타입 객체에서 가능한 모든 행위를 수행할 수 있어야 한다는 원칙이다. 즉, 상위 타입 객체를 하위 타입 객체로 대체해도 프로그램이 정상적으로 동작해야 한다.

> - **다형성 준수**: 하위 클래스는 상위 클래스와 인터페이스 규약을 모두 지켜야 한다.
> - **IS-A 관계**: 상속 관계에서는 일반환 관계(IS-A)가 반드시 성립해야 한다. 상속 관계가 아닌 클래스들 간의 상속은 LSP를 위반하게 된다.

예를 들어, 자동차 인터페이스가 있을 때, 액셀 기능은 자동차가 앞으로 이동해야 한다. 만약, 액셀 기능을 실행했을 때 자동차가 뒤로 간다면, 이는 LSP를 위반하는 것이다.
기능의 성능이 느리더라도, 액셀을 눌렀을 때 자동차는 항상 앞으로 가야 한다.

또한, LSP를 위반하면 OCP도 위반하게 되므로, 상속 관계를 명확히 정의하여 LSP를 준수하도록 설계해야 한다.

#### ISP (Interface Segregation Principle): 인터페이스 분리 원칙

`인터페이스 분리 원칙(ISP)`은 클라이언트가 자신이 사용하는 메서드에만 의존해야 한다는 원칙이다. 즉, 특정 클라이언트를 위한 여러 개의 인터페이스가 범용 인터페이스 하나보다 더 유리하다.

> - **세분화된 인터페이스**: 인터페이스는 클라이언트를 기준으로 잘게 나누어야 한다. 예를 들어, '자동차'라는 범용 인터페이스 대신 운전, 정비, 타이어 등의 세부 인터페이스로 나누는 것이 더 효과적이다.
> - **유지보수 용이성**: 세부적인 인터페이스로 나누면 특정 기능(예를 들어, 타이어 교체)에 대한 변경 시 해당 인터페이스만 확인하고 수정하면 된다.
> - **대체 가능성 증가**: 인터페이스가 명확해지고, 기능의 대체 가능성이 높아진다.

클라이언트가 필요로 하는 인터페이스를 분리함으로써, 클라이언트가 사용하지 않는 인터페이스에 변경이 발생하더라도 다른 인터페이스에는 영향을 주지 않도록 하는 것이 ISP의 핵심이다.

#### DIP (Dependency Inversion Principle): 의존 역전 원칙

`의존 역전 원칙(DIP)`은 "프로그래머는 구체화에 의존해서는 안 되고, 추상화에 의존해야 한다"는 원칙이다. 의존성 주입은 이를 실현하는 방법 중 하나이다.

> - **추상화에 의존**: 변하기 쉬운 구체적인 것보다는 변하기 어려운 추상적인 것에 의존해야 한다. 즉, 구현 클래스가 아니라 인터페이스에 의존해야 한다.
> - **유연한 구현체 변경**: 클라이언트가 인터페이스에 의존하면 구현체를 유연하게 변경할 수 있다. 반면, 구현체에 의존하면 변경이 어려워진다.
> - **모듈 간의 독립성**: 고수준 모듈은 저수준 모듈의 구현에 의존해서는 안 된다. 저수준 모듈이 변경되더라도 고수준 모듈은 영향을 받지 않는 구조가 이상적이다.

해당 원칙을 따르면 시스템의 유연성과 유지보수성이 향상된다. 의존성을 추상화하여 모듈 간의 결합도를 낮추는 것이 핵심이다.

</details>

<br>

<details>
<summary style="font-size: 1.5em; font-weight: bold;">객체지향, 절차지향, 함수형 프로그래밍의 차이점</summary>

### 프로그래밍 패러다임이란?

프로그래밍 패러다임은 프로그래머에게 프로그래밍 관점을 가지게 하고 코드를 어떻게 작성할지 결정하는 역할을 한다.

즉, 새로운 프로그래밍 패러다임을 통해서 새로운 방식으로 생각하는 방법을 배우게 되고, 이를 바탕으로 코드를 구현하게 된다.

현재까지의 프로그래밍 패러다임: 절차지향 -> 객체지향 -> 함수형
- **명령형 프로그래밍**: 무엇(What)을 할 건지를 나타내기보다 어떻게(How) 할 건지를 설명하는 방식이다.
  - `절차지향 프로그래밍`: 수행되어야 할 기능을 순차적인 처리 과정으로 진행하는 방식이다.
  - `객체지향 프로그래밍`: 객체들의 집합으로 프로그램의 상호작용으로 진행하는 방식이다.
- **선언형 프로그래밍**: 어떻게(How) 할 건지를 나타내기보다 무엇(What)을 할 건지를 설명하는 방식이다.
  - `함수형 프로그래밍`: 순수 함수를 조합하여 소프트웨어를 만드는 방식이다.

### 절차지향, 객체지향, 함수형 프로그래밍
#### 절차지향 프로그래밍 (Procedural Programming)
> 순차적인 처리를 중요하게 여기며, 프로그램 전체가 유기적으로 연결되도록 만드는 프로그래밍 기법이다.

절차지향 프로그래밍의 장점: 
- 코드의 가독성이 좋다.
- 코드를 단위화할 수 있다.
- 컴퓨터의 처리구조와 비슷해 실행 속도가 빠르다.

절차지향 프로그래밍의 단점: 
- 각각의 코드가 순서에 따라 실행되어, 변경과 유지보수 및 분석이 어렵다.
- 변수나 상수 등의 값들을 관리하는 자료형과 해당 자료형을 사용하는 함수가 분리되어 사용된다.

대표적인 절차지향 프로그래밍 언어는 `C`언어 등이 있다.

#### 객체지향 프로그래밍 (Object-Oriented Programming)
> 모든 데이터를 객체로 취급하여 객체가 처리 요청을 받았을 때 객체 내부에 있는 기능을 가져와 사용하여 처리하는 프로그래밍 기법으로, 
> 모든 객체가 내부의 자료형(Field)과 함수(Method)로 구성된 프로그래밍 구조를 의미한다.

객체지향 프로그래밍의 장점: 
- 코드의 재사용이 가능하여 유지보수가 용이하다.
- 분석과 설계의 전환이 쉽다.

객체지향 프로그래밍의 단점:
- 처리 속도가 상대적으로 느리다.
- 설계에 많은 시간이 소요된다.

대표적인 객체지향 프로그래밍 언어는 `Java`와 `Python` 등이 있다.

#### 함수형 프로그래밍 (Functional Programming)
> 순수 함수를 사용하여 상태를 제어하기보단 빠르게 처리하는데 초점을 둔 프로그래밍 기법으로, 
> 실행 순서를 지정할 필요가 없어 비절차형 언어라고도 한다.

함수형 프로그래밍의 장점: 
- 코드에서 프로그램의 실행에 영향을 미치는 영역과 순수한 영역을 최대한 분리한다.
- 코드의 가독성이 높아지고, 유지보수가 좋아진다.
- 테스트가 쉬워진다.

함수형 프로그래밍의 단점:
- 외부 데이터 혹은 내부 데이터의 상태를 조작할 수 없다.

대표적인 함수형 프로그래밍 언어는 `Haskell`과 `OCamal` 등이 있다.

##### 💡 순수 함수란?
> 동일한 입력 값을 넣었을 때, 동일한 리턴 값을 반환하며 외부에 영향을 받지 않는 함수로 함수의 실행이 프로그램에 영향을 주지 않는다.
> 때문에 비상태 불변성(전달된 데이터를 변경하는 것이 아닌, 새로운 버전이나 오브젝트를 만들어 결과 값으로 전달)을 유지하고 여러 가지 동시다발적인 멀티스레딩 환경에서도 안정적으로 동작할 수 있다.

### 절차지향 프로그래밍 vs 객체지향 프로그래밍
절차지향 프로그래밍 위에 객체지향 프로그래밍이 탄생한 것으로, 절차지향 프로그래밍이 갖는 부족함을 객체지향 프로그래밍이 보완해주는 역할을 한다.

> 절차지향 프로그래밍은 함수가 있고, 객체지향 프로그래밍 또한 함수가 있지만 `객체`라는 개념이 등장한다.

### 함수형 프로그래밍 vs 객체지향 프로그래밍
#### 1. 함수형 프로그래밍은 함수 자체가 `일급 객체`가 되지만, 객체지향 프로그래밍은 클래스(혹은 객체)가 `일급 객체`가 된다.

##### 💡 일급 객체란?
> 다른 요소들과 아무런 차별이 없는 객체로, 함수의 인자로도 넘겨질 수 있고 변수에 대입도 가능한 객체를 의미한다.

#### 2. 객체지향 프로그램에서는 프로그램을 상호작용하는 객체들의 집합으로 볼 수 있지만, 함수형 프로그래밍에서는 상태 값을 지니지 않은 함수들의 연속으로 볼 수 있다.

##### 객체지향 프로그래밍의 경우
> 클래스 디자인과 객체들의 관계를 중심으로 코드 작성이 이루어진다. 따라서 상태, 멤버변수, 메서드 등이 긴밀한 관계를 가지고 있다.
> 특히, 멤버변수가 어떤 상태를 가지고 있는가에 따라서 결과가 달라진다.

##### 함수형 프로그래밍의 경우
> 값의 연산 및 결과 도출 중심으로 코드 작성이 이루어진다. 함수는 인자로 받은 값을 별도로 저장하지 않고, 간결한 과정으로 처리하고 매핑하는 데 주 목적을 둔다.

</details>

## 2. Java 기본 개념

<details>
<summary style="font-size: 1.5em; font-weight: bold;">원시형(Primitive Type) vs 참조형(Reference Type)</summary>

### 원시 타입이란?
원시 타입은 Java에서 기본적으로 제공하는 데이터 타입으로, 실제 값을 직접 저장한다. 예를 들어, `int`, `boolean`, `char` 등이 있다.

### 참조 타입이란?
참조 타입은 객체를 참조하는 데이터 타입으로, 실제 데이터는 힙 메모리에 저장되고, 변수는 그 데이터의 메모리 주소를 저장한다. 예를 들어, `String`, 배열, 사용자 정의 클래스 등이 있다.

> 원시 타입의 변수는 실제 값을 변수 안에 저장하지만, 참조 타입의 변수는 메모리의 번지를 변수 안에 저장하여 저장된 메모리 주소 값을 통해 객체를 참조한다.

### 원시타입 vs 참조타입
#### 1. NULL
- 원시 타입은 Null을 담을 수 없으나, 참조 타입은 Null을 입력값으로 받을 수 있다.

```java
int i = null; // 불가능
Integer integer = null; // 가능
```

#### 2. 제네릭 타입
- 원시 타입은 제네릭 타입에서 사용할 수 없으나, 참조 타입은 제네릭 타입에서 사용할 수 있다.
```java
List<int> i; // 불가능
List<Integer> integer; // 가능
```

#### 3. 접근 속도, 메모리 양
원시 타입은 Null을 다루지 못하고, 제네릭에 담기지 못하지만, 원시 타입을 참조 타입과 비교해서 갖는 장점은 성능상의 이점이 존재한다.

- **접근 속도**: 
  - 원시 타입은 `스택` 메모리에 값이 존재하는 반면, 참조 타입은 하나의 인스턴스이므로 스택 메모리에는 참조값만 있고, 실제 값은 `힙` 메모리에 존재한다.
  - 참조 타입은 값을 필요로 할 때마다 언박싱(Unboxing) 과정을 거쳐야 하므로 원시 타입과 비교했을 때 접근 속도가 느리다.
- **메모리 양**: 
  - 원시 타입은 메모리를 적게 차지하는 반면, 참조 타입은 훨씬 많은 메모리를 사용한다.

##### 💡 박싱(Boxing) & 언박싱(Unboxing)
박싱(Boxing)은 원시 타입을 참조 타입으로 변환시키는 것을 의미하며, 언박싱(Unboxing)은 참조 타입을 원시 타입으로 변환시키는 것을 의미한다.

박싱은 값 타입을 참조 타입으로 변환하여 값을 포함하는 객체를 힙에 생성하는 것이며, 언박싱은 박싱된 참조 타입으로부터 원래의 값을 다시 추출하는 연산을 의미한다.

Java 1.5 이전에는 모두 변환 과정을 거쳐야 했지만, 자바 1.5부터 추가된 Auto Boxing/Unboxing 기능으로 아래의 예시와 같이 명시적으로 원시 타입을 참조 타입으로 감싸지 않아도 자동으로 변환된다.
```java
int i = 15;
Integer integer = i;
```

> 그러나, Auto Boxing/Unboxing 기능은 컴파일러 내부적으로 추가 연산작업을 거치게 되어 메모리 누수의 원인이 될 수 있다.
> 따라서, 성능 향상을 위해서 Auto Boxing/Unboxing이 일어나지 않도록 동일한 타입 연산이 이루어지도록 구현하는 것이 좋다.

</details>












---

## 참고자료
- [객체지향 프로그래밍의 4가지 특징](https://jja2han.tistory.com/330)
- [SOLID 5원칙](https://velog.io/@pp8817/SOLID-%EC%A2%8B%EC%9D%80-%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%EC%84%A4%EA%B3%84%EC%9D%98-5%EA%B0%80%EC%A7%80-%EC%9B%90%EC%B9%99)
- [객체지향 vs 절차지향 vs 함수형 프로그래밍](https://velog.io/@majaeh43/%EC%A0%88%EC%B0%A8%EC%A7%80%ED%96%A5-%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%8D)
- [원시 타입 vs 참조 타입](https://velog.io/@m1naworld/Java-%EC%9B%90%EC%8B%9C-%ED%83%80%EC%9E%85Primitive-Type-VS-%EC%B0%B8%EC%A1%B0-%ED%83%80%EC%9E%85Reference-Type)
