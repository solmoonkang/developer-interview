# 01. JAVA

- [1. 객체지향 프로그래밍의 기본 개념](#1-객체지향-프로그래밍의-기본-개념)
    - [객체 지향 프로그래밍의 4가지 특징](#객체-지향-프로그래밍의-4가지-특징)
    - [SOLID 5원칙](#solid-5원칙)
    - [객체지향, 절차지향, 함수형 프로그래밍의 차이점](#객체지향-절차지향-함수형-프로그래밍의-차이점)

---

## 1. 객체지향 프로그래밍의 기본 개념

<details>
<summary style="font-size: 1.5em; font-weight: bold;">객체 지향 프로그래밍의 4가지 특징</summary>

### 추상화 (Abstraction)
> 객체들이 공통적으로 필요로 하는 속성이나 동작을 하나로 추출해 내는 작업

즉, 알고는 있지만, 정확하게 표현하기 힘든 것들을 중요한 부분이나 특징점으로 잡아 설명하는 것을 추상화한다고 할 수 있다.
프로그래밍에서 추상화는 클래스를 정의할 때 불필요한 부분들을 생략하고 객체의 속성 중 중요한 것에만 중점을 두어 개략화하는 것을 말한다.

예를 들면, 삼성폰과 아이폰이라는 객체가 있을 때, 이 객체들을 하나로 묶을 때 공통적인 특징을 휴대폰으로 묶어서 이름을 붙이는 것을 추상화하고 할 수 있다.
이처럼 공통된 기능을 휴대폰에서 미리 구현을 하고, 상속을 통해서 공통된 기능을 삼성폰과 아이폰에 이어주면 삼성폰과 아이폰은 각자의 고유기능을 집중적으로 개발할 수 있다.
이럴 경우, 공통된 기능을 다시 정의할 필요가 없어 코드의 중복이 줄어들고, 코드의 재사용성이 용이해지는 장점이 있다.

> 즉, 추상화로 구현을 하면 새로운 객체를 만들 때 클래스의 고유기능만 새로 만들어주고, 공통된 기능은 상속을 통해서 이용이 가능하다.

### 상속 (Inheritance)
> 여러 개체들이 지닌 공통된 특성을 추출하여 하나의 개념이나 법칙으로 성립하는 과정이

예를 들어, 삼성폰과 아이폰은 모두 휴대폰이자 통신기기이며 전자제품이라는 공통적인 속성을 가지고 있다. 이처럼 삼성폰 & 아이폰, 휴대폰, 통신기기, 전자제품은 중복된 속성을 포함하고 있다.
이러한 속성들을 각 클래스마다 개별적으로 정의하기보다는, 공통된 속성들을 하나의 클래스로 묶어 상속을 통해 재사용하는 것이 훨씬 효율적인 프로그래밍 방법이다.

상속을 통해 하위 클래스는 상위 클래스의 변수와 메서드를 물려받아 재사용할 수 있다. 이로 인해 코드의 중복을 줄이고, 유지보수성을 높일 수 있다.

### 다형성 (Polymorphism)
> 프로그래밍에서의 다형성이란 같은 자료형에 여러가지 타입의 데이터를 대입하여 다양한 결과를 얻어낼 수 있는 성질을 의미

비유적으로 표현하자면, 한 명의 남자는 특정 상황에서 여러 가지 역할을 수행한다. 누군가에게는 친구, 자식에게는 아버지, 동아리에서는 리더, 아내에게는 남편, 부모님에게는 자식이 될 수 있다.
이처럼 객체도 상황에 따라 여러가지 형태를 가질 수 있다는 것이 다형성의 핵심이다. 대표적인 예로는 `메서드 오버라이딩`과 `메서드 오버로딩`이 있다.

#### 💡 메서드 오버라이딩 (Overriding)
- 부모 클래스의 메서드를 자식 클래스에서 재정의해서 사용하는 것을 의미한다. 자식 클래스는 부모 클래스의 메서드를 재활용하면서 독자적인 기능을 추가할 수 있다.

#### 💡 메서드 오버로딩 (Overloading)
- 같은 이름의 메서드를 다양한 매개변수 타입과 개수로 정의하는 것을 의미한다. 오버로딩은 메서드 이름을 동일하게 유지하면서도 다양한 상황에서 유연하게 대응할 수 있는 방법을 제공한다.

적절하게 다형성을 활용하면 코드의 재사용성과 유연성을 높이고, 불필요한 코드 중복과 결합도를 낮춰서 유지보수성을 높일 수 있다. 그러나 무분별한 오버로딩은 코드의 동작을 이해하는 데 어려움을 줄 수 있으므로, 적절한 사용이 필요하다.

### 캡슐화 (Encapsultation)
> 객체지향에서의 캡슐화는 데이터와 메서드를 하나의 단위로 묶어 외부에서 접근하지 못하도록 보호하는 개념

예를 들어, 알약은 그 안에 어떤 구성물질이 들어 있는지 알 수 없으며, 내용물은 캡슐을 통해서 안전하게 보호된다. 이처럼 캡슐화는 외부에서 알 필요가 없는 부분을 감춤으로써 대상을 단순화하는 추상화의 한 형태이다.

#### 💡 캡슐화를 해야 하는 이유
- **데이터 보호**:
  - 외부로부터 클래스에 정의된 속성과 기능들을 보호한다.
- **데이터 은닉**:
  - 내부의 동작을 감추고 외부에는 필요한 부분만 노출한다.

캡슐화가 중요한 이유는 불안정한 부분과 안정적인 부분을 분리하여 변경의 영향을 통제할 수 있기 때문이다. 불안정한 부분은 객체 내부로 추상화해서 변경을 최소화하고, 안정적인 부분은 외부에 공개한다. 
이렇게 객체의 외부와 내부를 구분하면 구현 변경의 폭이 넓이지고, 변경의 영향을 효과적으로 관리할 수 있다. 또한, 캡슐화를 통해 코드 작성 이후의 추가 요구사항에도 유연하게 대처할 수 있다.

</details>

<br>

<details>
<summary style="font-size: 1.5em; font-weight: bold;">SOLID 5원칙</summary>

### 객체지향 설계의 5가지 원칙, SOLID

**SOLID**는 `SRP(단일 책임)`, `OCP(개방-폐쇄)`, `LSP(리스코프 치환)`, `ISP(인터페이스 분리)`, `DIP(의존 역전)`로, SOLID 원칙을 지키면 시간이 지나도 변경이 용이하고, 유지보수와 확장이 쉬운 소프트웨어를 개발하는데 도움이 된다.

#### SRP (Single Responsibility Principle): 단일 책임 원칙

`단일 책임 원칙(SRP)`은 하나의 클래스가 오직 하나의 책임만 가져야 한다는 원칙이다. 즉, 클래스는 하나의 기능에 대해 변경이 필요할 때만 수정되어야 하며, 이는 유지보수의 효율성을 높인다.

> - **책임의 정의**: 클래스가 수행하는 기능을 의미한다.
> - **변경 이유**: 클래스의 변경 이유는 단 하나여야 하며, 이를 통해 파급 효과를 최소화할 수 있다.
> - **유지보수 효율성**: 여러 책임을 가진 클래스는 서로 영향을 주어 유지보수가 비효율적이 된다.
> - **응집도와 결합도**: 높은 응집도와 낮은 결합도를 유지해야 하며, 이를 통해 코드의 품질을 높일 수 있다.

예를 들어, 하나의 클래스가 여러 기능을 수행하면, 내부 함수 간의 결합도가 높아져 코드 효율성이 떨어질 수 있다. 따라서 각 클래스는 명확한 책임을 가져야 한다.

#### OCP (Open-Closed Principle): 개방-폐쇄 원칙

`개방-폐쇄 원칙(OCP)`은 소프트웨어 요소가 **확장에는 열려 있으나 변경에는 닫혀 있어야 한다**는 원칙이다. 즉, 기존 코드를 수정하지 않고도 기능을 추가하거나 변경할 수 있도록 설계해야 한다.

> - **기능 수정**: 새로운 클래스를 생성하여 기존 인터페이스를 구현함으로써 기능을 확장할 수 있다.
> - **유지보수 간소화**: 특정 모듈의 기능을 수정할 때, 해당 모듈을 사용하는 모든 모듈을 수정할 필요가 없어 유지보수가 간편해진다.
> - **장점**: OCP를 지키면 유연성, 재사용성, 유지보수성을 극대화할 수 있다.

OCP를 구현하기 위해서는 기존 코드를 변경하지 않고 기능을 수정하거나 추가하기 위해서 `상속(다형성)`과 `추상화(인터페이스)`를 활용해야 한다. 자주 변경되는 부분을 추상화하여 기존 코드의 수정을 최소화하고, 기능 확장을 용이하게 한다.

#### LSP (Liskov Substitution Principle): 리스코프 치환 원칙

`리스코프 치환 원칙(LSP)`은 하위 타입 객체가 상위 타입 객체에서 가능한 모든 행위를 수행할 수 있어야 한다는 원칙이다. 즉, 상위 타입 객체를 하위 타입 객체로 대체해도 프로그램이 정상적으로 동작해야 한다.

> - **다형성 준수**: 하위 클래스는 상위 클래스와 인터페이스 규약을 모두 지켜야 한다.
> - **IS-A 관계**: 상속 관계에서는 일반환 관계(IS-A)가 반드시 성립해야 한다. 상속 관계가 아닌 클래스들 간의 상속은 LSP를 위반하게 된다.

예를 들어, 자동차 인터페이스가 있을 때, 액셀 기능은 자동차가 앞으로 이동해야 한다. 만약, 액셀 기능을 실행했을 때 자동차가 뒤로 간다면, 이는 LSP를 위반하는 것이다.
기능의 성능이 느리더라도, 액셀을 눌렀을 때 자동차는 항상 앞으로 가야 한다.

또한, LSP를 위반하면 OCP도 위반하게 되므로, 상속 관계를 명확히 정의하여 LSP를 준수하도록 설계해야 한다.

#### ISP (Interface Segregation Principle): 인터페이스 분리 원칙

`인터페이스 분리 원칙(ISP)`은 클라이언트가 자신이 사용하는 메서드에만 의존해야 한다는 원칙이다. 즉, 특정 클라이언트를 위한 여러 개의 인터페이스가 범용 인터페이스 하나보다 더 유리하다.

> - **세분화된 인터페이스**: 인터페이스는 클라이언트를 기준으로 잘게 나누어야 한다. 예를 들어, '자동차'라는 범용 인터페이스 대신 운전, 정비, 타이어 등의 세부 인터페이스로 나누는 것이 더 효과적이다.
> - **유지보수 용이성**: 세부적인 인터페이스로 나누면 특정 기능(예를 들어, 타이어 교체)에 대한 변경 시 해당 인터페이스만 확인하고 수정하면 된다.
> - **대체 가능성 증가**: 인터페이스가 명확해지고, 기능의 대체 가능성이 높아진다.

클라이언트가 필요로 하는 인터페이스를 분리함으로써, 클라이언트가 사용하지 않는 인터페이스에 변경이 발생하더라도 다른 인터페이스에는 영향을 주지 않도록 하는 것이 ISP의 핵심이다.

#### DIP (Dependency Inversion Principle): 의존 역전 원칙

`의존 역전 원칙(DIP)`은 "프로그래머는 구체화에 의존해서는 안 되고, 추상화에 의존해야 한다"는 원칙이다. 의존성 주입은 이를 실현하는 방법 중 하나이다.

> - **추상화에 의존**: 변하기 쉬운 구체적인 것보다는 변하기 어려운 추상적인 것에 의존해야 한다. 즉, 구현 클래스가 아니라 인터페이스에 의존해야 한다.
> - **유연한 구현체 변경**: 클라이언트가 인터페이스에 의존하면 구현체를 유연하게 변경할 수 있다. 반면, 구현체에 의존하면 변경이 어려워진다.
> - **모듈 간의 독립성**: 고수준 모듈은 저수준 모듈의 구현에 의존해서는 안 된다. 저수준 모듈이 변경되더라도 고수준 모듈은 영향을 받지 않는 구조가 이상적이다.

해당 원칙을 따르면 시스템의 유연성과 유지보수성이 향상된다. 의존성을 추상화하여 모듈 간의 결합도를 낮추는 것이 핵심이다.

</details>

<br>

<details>
<summary style="font-size: 1.5em; font-weight: bold;">객체지향, 절차지향, 함수형 프로그래밍의 차이점</summary>

### 

</details>

---

## 참고자료
- https://jja2han.tistory.com/330
- https://velog.io/@pp8817/SOLID-%EC%A2%8B%EC%9D%80-%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%EC%84%A4%EA%B3%84%EC%9D%98-5%EA%B0%80%EC%A7%80-%EC%9B%90%EC%B9%99
