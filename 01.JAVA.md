# 01. JAVA

- [equals()와 hashCode() 메소드의 차이점](#equals와-hashcode-메소드의-차이점은-무엇일까요?)
- [StringBuilder와 StringBuffer의 차이점](#stringbuilder와-stringbuffer의-차이는-무엇일까요?)
- [System.out.println 메소드를 현업에서 쓰지 말라고 하는 이유](#systemoutprintln-메소드를-현업에서-쓰지-말라고-하는-이유가-무엇일까요?)
- [ArrayList의 내부 구현](#arraylist는-내부적으로-어떻게-구현되어있을까요?)
- [스레드를 사용하는 이유](#스레드는-왜-써야하는-것일까요?)
- [동시성 문제](#0이-들어있는-변수에-10개의-스레드가-동시에-접근해서--연산을-하면-우리-예상과-다르게-10이-나오지-않습니다-왜-그럴까요?)
- [동시성 관련 예약어](#자바에서-동시성과-관련된-예약어를-모두-말씀해주세요)
- [Blocking IO와 Non-Blocking IO의 차이](#blocking-io와-non-blocking-io의-차이를-말씀해주세요)
- [Serializable 란](#serializable은-무엇일까요?)

<br>

<details>
<summary style="font-size: 1.5em; font-weight: bold;">equals( )와 hashCode( ) 메소드의 차이점은 무엇일까요?</summary>

### equals( ) 메서드와 hashCode( ) 메서드
**equals 메서드**는 두 객체의 `동등성`을 비교하는 메서드이다. 즉, 두 객체가 같은 내용을 가지고 있는지를 판단한다. 기본적으로 자바의 Object 클래스에서 제공되는 equals 메서드는 객체의 메모리 주소를 비교하여 동일성을 검사한다.
하지만, 일반적으로는 이 메서드를 오버라이드하여 객체의 필드 값을 기반으로 비교하도록 구현한다.

**hashCode 메서드**는 객체의 `동일성`을 기반으로 해시 코드를 반환하는 메서드이다. 이 해시 코드는 객체를 해시 기반의 컬렉션(EX. HashMap)에서 효율적으로 저장하고 검색할 수 있도록 도와준다.
기본적으로 hashCode 메서드도 객체의 메모리 주소를 기반으로 해시 코드를 생성하지만, 오버라이드하여 객체의 필드 값을 기반으로 해시 코드를 생성할 수 있다.

### equals( ) 메서드와 hashCode( ) 메서드의 차이점
- **동등성(`equals`)**: equals( ) 메서드는 두 객체가 '동등한지' 즉, 같은 내용을 가지고 있는지를 비교한다. 기본적으로 Object 클래스의 equals( ) 메서드는 참조(메모리 주소)를 비교하지만, 이 메서드를 오버라이드하여 객체의 필드 값을 기반으로 비교할 수 있다.
- **동일성(`hashCode`)**: hashCode( ) 메서드는 객체의 '동일성'을 기준으로 해시 코드를 생성한다. 기본적으로는 객체의 메모리 주소를 기반으로 해시 코드를 반환하지만, 이 메서드도 오버라이드할 수 있어서 특정 필드 값을 기반으로 해시 코드를 정의할 수 있다. 해시 기반의 컬렉션에서 객체를 효율적으로 관리하기 위해 중요하다.

<br>

<details>
<summary style="font-size: 1.5em; font-weight: bold;">❓ 잘못 답변할 수 있는 케이스</summary>

#### "hashCode"는 객체의 메모리 주소를 리턴한다고 하는데, 그럼 우리가 "hashCode"를 오버라이드 했을 때에도 메모리 주소를 리턴할 수 있을까요? 자바에서는 개발자가 직접 메모리에 접근할 수 있나요?
> hashCode 메서드를 오버라이드할 경우 개발자가 원하는 방식으로 해시 코드를 정의할 수 있기 때문이다. 자바에서는 개발자가 직접 메모리에 접근할 수 없으므로, hashCode 메서드는 객체의 필드 값을 기반으로 해시 코드를 생성하도록 구현할 수 있다. 따라서 해시 코드는 메모리 주소와는 무관한 값이 될 수 있다.

</details>

<details>
<summary style="font-size: 1.5em; font-weight: bold;">❓ 꼬리질문</summary>

#### "hashCode"를 잘못 오버라이딩하면 "HashMap" 등 hash 콜렉션의 성능이 떨어질 수가 있는데, 어떤 케이스일 때 그럴 수 있나요?
> hashCode 메서드를 잘못 오버라이드하면 HashMap과 같은 해시 기반 컬렉션의 성능이 저하될 수 있다. 예를 들어, 두 객체가 equals 메서드로 동등하더라도 서로 다른 해시 코드를 반환하는 경우, HashMap은 이 객체들을 서로 다른 위치에 저장하게 된다. 이로 인해 HashMap의 성능이 떨어지며, 충돌이 많이 발생하여 LinkedList 형태로 저장되거나 Red-Black Tree로 변환될 수 있다.

#### "HashMap"은 내부적으로 어떻게 구현되어 있길래 빨리 값을 탐색할 수 있나요?
> HashMap은 내부적으로 배열과 LinkedList 또는 Red-Black Tree를 사용하여 구현되어 있다. 기본적으로 배열의 각 인덱스는 해시 코드에 따라 객체가 저장되는 버킷을 의미한다. 만약 해시 코드가 충돌하면, 해당 인덱스에 LinkedList가 생성되어 여러 객체가 저장된다. 충돌이 많이 발생할 경우, LinkedList가 길어지면서 성능이 저하되므로, Java 8부터는 LinkedList가 일정 길이를 넘으면 Red-Black Tree로 변환되어 성능을 개선한다.

#### 기존 "HashMap"의 시간 복잡도는 얼마이고, "hashCode"를 잘못 오버라이딩 했을 때의 시간복잡도는 얼마일까요?
> 기존 HashMap의 평균적인 검색, 삽입, 삭제 시간 복잡도는 O(1)이다. 하지만 해시 충돌이 많아져서 LinkedList가 길어지거나 Red-Black Tree로 변환될 경우, 최악의 경우 시간 복잡도는 O(n)까지 증가할 수 있다. 잘못 오버라이드된 hashCode로 인해 충돌이 많아지면, 이러한 최악의 상황이 발생할 수 있다. 따라서 hashCode 메서드를 적절히 오버라이드하는 것이 중요하다.

</details>
</details>

<br>

<details>
<summary style="font-size: 1.5em; font-weight: bold;">StringBuilder와 StringBuffer의 차이는 무엇일까요?</summary>

StringBuilder & StringBuffer 클래스는 문자열을 연산(추가하거나 변경)할 때 주로 사용하는 자료형이다.

- **StringBuilder**: 문자열 파싱 성능이 가장 우수하지만, 동기화(Synchronization)를 지원하지 않아 멀티 스레드 환경에서 안전하지 않다.
- **StringBuffer**: 동기화(Synchronization)를 지원하여 멀티 스레드 환경에서 안전하다.

> JAVA에서 synchronized 키워드는 여러 스레드가 하나의 자원에 접근할 때, 현재 데이터를 사용하는 스레드를 제외한 나머지 스레드가 데이터에 접근할 수 없도록 막는 역할을 수행한다.

</details>

<br>

<details>
<summary style="font-size: 1.5em; font-weight: bold;">System.out.println 메소드를 현업에서 쓰지 말라고 하는 이유가 무엇일까요?</summary>

System.out.println 메서드는 Java 개발할 때 디버깅 용도로 콘솔에 출력하는 메서드 중 하나이다.
> System은 java.lang 패키지의 내장된 최종 클래스며, out은 System 클래스의 정적 멤버 필드로 PrintStream이며, println은 PrintStream 클래스의 메서로 표준 콘솔에 전달된 인자와 줄바꿈을 출력한다.

- **1. 성능 이슈**: 
  - 블로킹 I/O와 멀티스레드에서 LOCK이 발생한다.
  - System.out.println이 끝날 때까지 아무 일을 실행할 수 없고, 대기해야 하기 때문에 성능을 저하시킬 수 있다.
- **2. 로그 레벨 관리의 어려움**: 
  - 로그 레벨을 지정할 수 없기 때문에 디버깅 용도로 사용되는 경우, 어떤 로그 레벨로 출력되는지 확인하기 어렵다.
  - 로그 레벨이 제대로 관리되지 않으면, 프로덕션 환경에서도 불필요한 디버깅 정보가 출력되어 시스템의 안정성과 보안에 문제가 생길 수 있다.
- **3. 유지보수성 저하**: 
  - 출력 메시지가 코드에 하드코딩이 되어 있다면, 이후 메시지를 수정하거나 삭제하는 등의 변경 작업에 어려움이 생길 수 있다.

> 운영 시스템에서 System.out.println을 사용하기 보다 로깅 프레임워크(logback OR log4j)를 사용하여 적절한 로그 레벨을 지정하여 출력하는 것이 좋다.

</details>

<br>

<details>
<summary style="font-size: 1.5em; font-weight: bold;">ArrayList 는 내부적으로 어떻게 구현되어있을까요?</summary>
여기에 내용을 작성하세요.
</details>

<br>

<details>
<summary style="font-size: 1.5em; font-weight: bold;">스레드는 왜 써야하는 것일까요?</summary>

스레드는 프로세스 내에서 실행되는 경량의 실행 단위이다. 하나의 프로세스는 여러 개의 스레드를 가질 수 있으며, 이들은 자원을 공유하면서 동시에 작업을 수행할 수 있다.

- **1. 병렬 처리**: 스레드를 사용하면 여러 작업을 동시에 수행할 수 있다. 이는 CPU의 멀티코어 기능을 활용하여 성능을 극대화할 수 있게 해준다.
- **2. 자원 공유**: 스레드는 같은 프로세스 내에서 메모리 공간을 공유하므로, 스레드 간의 데이터 전송이 빠르고 효율적이다. 이로 인해 데이터 공유와 통신이 용이하며, 자원을 절약할 수 있다.
- **3. 응답성 향상**: GUI 애플리케이션에서 스레드를 사용하면 사용자 인터페이스가 블로킹되지 않고, 사용자와의 상호작용을 계속 유지할 수 있다.
- **4. 비동기 작업**: 스레드를 사용하여 비동기적으로 작업을 수행할 수 있다. 이는 작업 완료를 기다리지 않고 다른 작업을 계속 진행할 수 있게 해준다.
- **5. 성능 향상**: CPU 바운드 작업이나 I/O 바운드 작업에서 스레드를 사용하면 성능을 최적화할 수 있다. 특히, I/O 작업은 대기 시간이 길기 때문에 다른 스레드가 실행될 수 있도록 하여 자원을 효율적으로 사용할 수 있다.

> 스레드는 병렬 처리, 자원 공유, 응답성 향상 등 다양한 장점을 제공하여 프로그램의 성능과 효율성을 높이는 데 중요한 역할을 한다. 하지만 스레드 사용 시 동기화 문제, 데드락과 같은 복잡성이 증가할 수 있으므로 적절한 설계가 필요하다.

</details>

<br>

<details>
<summary style="font-size: 1.5em; font-weight: bold;">0이 들어있는 변수에 10개의 스레드가 동시에 접근해서 ++ 연산을 하면 우리 예상과 다르게 10이 나오지 않습니다. 왜 그럴까요?</summary>

- **1. 원자성 부족**: ++ 연산은 실제로 두 개의 작업으로 구성된다. 첫째, 현재 값을 읽고, 둘째, 그 값을 1 증가시킨 후 다시 저장하는 과정이다. 해당 과정이 원자적이지 않기 때문에, 여러 스레드가 동시에 같은 변수를 읽고 수정할 경우, 서로의 작업이 겹칠 수 있다.
- **2. 경쟁 조건(Race Condition)**: 여러 스레드가 동시에 같은 변수를 수정하는 경우, 어떤 스레드가 먼저 실행될지 예측할 수 없다. 예를 들어, 스레드 A가 변수를 읽은 후, 스레드 B가 같은 변수를 읽고 1을 더한 후 저장할 수 있다. 이 경우, 두 스레드 모두 원래의 값인 0을 읽었기 때문에 최종적으로 1만 증가하게 된다.
- **3. 결과의 비결정성**: 스레드의 실행 순서는 운영체제에 의해 관리되며, 이는 예측할 수 없는 결과를 초래한다. 각 스레드가 ++ 연산을 수행할 때, 실행 순서에 따라 결과가 달라질 수 있다.

따라서 해당 문제를 해결하기 위해 synchronized 키워드나 AtomicInteger와 같은 동기화 메커니즘을 사용할 수 있다. 이렇게 하면 동시에 접근하는 스레드가 없도록 하여 원자적인 연산을 보장할 수 있다.

</details>

<br>

<details>
<summary style="font-size: 1.5em; font-weight: bold;">자바에서 동시성과 관련된 예약어를 모두 말씀해주세요.</summary>

</details>

<br>

<details>
<summary style="font-size: 1.5em; font-weight: bold;">Blocking IO와 Non-Blocking IO 의 차이를 말씀해주세요.</summary>

</details>

<br>

<details>
<summary style="font-size: 1.5em; font-weight: bold;">Serializable 은 무엇일까요?</summary>

</details>
