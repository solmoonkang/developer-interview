# 01. JAVA

- [equals()와 hashCode() 메소드의 차이점](#equals와-hashcode-메소드의-차이점은-무엇일까요?)
- [StringBuilder와 StringBuffer의 차이점](#stringbuilder와-stringbuffer의-차이는-무엇일까요?)
- [System.out.println 메소드를 현업에서 쓰지 말라고 하는 이유](#systemoutprintln-메소드를-현업에서-쓰지-말라고-하는-이유가-무엇일까요?)
- [ArrayList의 내부 구현](#arraylist는-내부적으로-어떻게-구현되어있을까요?)
- [스레드를 사용하는 이유](#스레드는-왜-써야하는-것일까요?)
- [동시성 문제](#0이-들어있는-변수에-10개의-스레드가-동시에-접근해서--연산을-하면-우리-예상과-다르게-10이-나오지-않습니다-왜-그럴까요?)
- [동시성 관련 예약어](#자바에서-동시성과-관련된-예약어를-모두-말씀해주세요)
- [Blocking IO와 Non-Blocking IO의 차이](#blocking-io와-non-blocking-io의-차이를-말씀해주세요)
- [Serializable 란](#serializable은-무엇일까요?)

<br>

<details>
<summary style="font-size: 1.5em; font-weight: bold;">equals( )와 hashCode( ) 메소드의 차이점은 무엇일까요?</summary>

### equals( ) 메서드와 hashCode( ) 메서드
**equals 메서드**는 두 객체의 `동등성`을 비교하는 메서드이다. 즉, 두 객체가 같은 내용을 가지고 있는지를 판단한다. 기본적으로 자바의 Object 클래스에서 제공되는 equals 메서드는 객체의 메모리 주소를 비교하여 동일성을 검사한다.
하지만, 일반적으로는 이 메서드를 오버라이드하여 객체의 필드 값을 기반으로 비교하도록 구현한다.

**hashCode 메서드**는 객체의 `동일성`을 기반으로 해시 코드를 반환하는 메서드이다. 이 해시 코드는 객체를 해시 기반의 컬렉션(EX. HashMap)에서 효율적으로 저장하고 검색할 수 있도록 도와준다.
기본적으로 hashCode 메서드도 객체의 메모리 주소를 기반으로 해시 코드를 생성하지만, 오버라이드하여 객체의 필드 값을 기반으로 해시 코드를 생성할 수 있다.

### equals( ) 메서드와 hashCode( ) 메서드의 차이점
- **동등성(`equals`)**: equals( ) 메서드는 두 객체가 '동등한지' 즉, 같은 내용을 가지고 있는지를 비교한다. 기본적으로 Object 클래스의 equals( ) 메서드는 참조(메모리 주소)를 비교하지만, 이 메서드를 오버라이드하여 객체의 필드 값을 기반으로 비교할 수 있다.
- **동일성(`hashCode`)**: hashCode( ) 메서드는 객체의 '동일성'을 기준으로 해시 코드를 생성한다. 기본적으로는 객체의 메모리 주소를 기반으로 해시 코드를 반환하지만, 이 메서드도 오버라이드할 수 있어서 특정 필드 값을 기반으로 해시 코드를 정의할 수 있다. 해시 기반의 컬렉션에서 객체를 효율적으로 관리하기 위해 중요하다.

<br>

<details>
<summary style="font-size: 1.5em; font-weight: bold;">❓ 잘못 답변할 수 있는 케이스</summary>

#### "hashCode"는 객체의 메모리 주소를 리턴한다고 하는데, 그럼 우리가 "hashCode"를 오버라이드 했을 때에도 메모리 주소를 리턴할 수 있을까요? 자바에서는 개발자가 직접 메모리에 접근할 수 있나요?
> hashCode 메서드를 오버라이드할 경우 개발자가 원하는 방식으로 해시 코드를 정의할 수 있기 때문이다. 자바에서는 개발자가 직접 메모리에 접근할 수 없으므로, hashCode 메서드는 객체의 필드 값을 기반으로 해시 코드를 생성하도록 구현할 수 있다. 따라서 해시 코드는 메모리 주소와는 무관한 값이 될 수 있다.

</details>

<details>
<summary style="font-size: 1.5em; font-weight: bold;">❓ 꼬리질문</summary>

#### "hashCode"를 잘못 오버라이딩하면 "HashMap" 등 hash 콜렉션의 성능이 떨어질 수가 있는데, 어떤 케이스일 때 그럴 수 있나요?
> hashCode 메서드를 잘못 오버라이드하면 HashMap과 같은 해시 기반 컬렉션의 성능이 저하될 수 있다. 예를 들어, 두 객체가 equals 메서드로 동등하더라도 서로 다른 해시 코드를 반환하는 경우, HashMap은 이 객체들을 서로 다른 위치에 저장하게 된다. 이로 인해 HashMap의 성능이 떨어지며, 충돌이 많이 발생하여 LinkedList 형태로 저장되거나 Red-Black Tree로 변환될 수 있다.

#### "HashMap"은 내부적으로 어떻게 구현되어 있길래 빨리 값을 탐색할 수 있나요?
> HashMap은 내부적으로 배열과 LinkedList 또는 Red-Black Tree를 사용하여 구현되어 있다. 기본적으로 배열의 각 인덱스는 해시 코드에 따라 객체가 저장되는 버킷을 의미한다. 만약 해시 코드가 충돌하면, 해당 인덱스에 LinkedList가 생성되어 여러 객체가 저장된다. 충돌이 많이 발생할 경우, LinkedList가 길어지면서 성능이 저하되므로, Java 8부터는 LinkedList가 일정 길이를 넘으면 Red-Black Tree로 변환되어 성능을 개선한다.

#### 기존 "HashMap"의 시간 복잡도는 얼마이고, "hashCode"를 잘못 오버라이딩 했을 때의 시간복잡도는 얼마일까요?
> 기존 HashMap의 평균적인 검색, 삽입, 삭제 시간 복잡도는 O(1)이다. 하지만 해시 충돌이 많아져서 LinkedList가 길어지거나 Red-Black Tree로 변환될 경우, 최악의 경우 시간 복잡도는 O(n)까지 증가할 수 있다. 잘못 오버라이드된 hashCode로 인해 충돌이 많아지면, 이러한 최악의 상황이 발생할 수 있다. 따라서 hashCode 메서드를 적절히 오버라이드하는 것이 중요하다.

</details>
</details>

<br>

<details>
<summary style="font-size: 1.5em; font-weight: bold;">StringBuilder와 StringBuffer의 차이는 무엇일까요?</summary>

### StringBuilder와 StringBuffer의 차이점
StringBuilder와 StringBuffer는 Java에서 문자열을 조작하기 위한 클래스로 두 클래스는 비슷한 기능을 제공하지만, 중요한 차이점이 있다.
- **1. 동기화(Synchronization)**: 
  - `StringBuffer`: 동기화된 클래스로 여러 스레드가 동시에 접근할 때 안전하게 사용할 수 있도록 설계되었다. 그 결과, 멀티스레드 환경에서 안전하지만 성능이 저하될 수 있다.
  - `StringBuilder`: 동기화되지 않은 클래스로 멀티스레드 환경에서는 안전하지는 않지만, 단일 스레드에서 사용할 때는 더 빠르다.
- **2. 성능**: 
  - `StringBuffer`는 동기화로 인해 성능이 떨어지므로, 단일 스레드 환경에서는 `StringBuilder`가 더 빠르다.
  - `StringBuilder`는 동기화가 없기 때문에 더 빠른 성능을 제공한다.
- **3. 용도**: 
  - `StringBuffer`는 멀티스레드 환경에서 문자열을 안전하게 조작해야 할 때 사용한다.
  - `StringBuilder`는 단일 스레드 환경에서 문자열을 조작할 때 주로 사용한다.

<details>
<summary style="font-size: 1.5em; font-weight: bold;">❓ 꼬리 질문</summary>

#### 왜 동기화(Synchronized)가 걸려있으면 느린걸까요?
> 동기화가 걸리면, 특정 스레드가 공유 자원에 접근할 때 다른 스레드가 동시에 접근하지 못하도록 막는다. 이로 인해 스레드 간의 경쟁 상태(Race Condition)를 방지할 수 있지만, 다음과 같은 이유로 성능이 저하된다.
> - **대기 시간**: 한 스레드가 동기화된 블록에 들어가면 다른 스레드는 그 블록이 해제될 때까지 기다려야 한다. 이로 인해 대기 시간이 발생한다.
> - **오버헤드**: 동기화는 추가적인 오버헤드를 발생시킨다. 스레드가 동기화된 메서드에 들어오고 나갈 때마다 상태를 체크해야 하므로 성능이 저하된다.

#### 싱글 스레드로 접근한다는 가정하에선 `StringBuilder`와 `StringBuffer`의 성능이 똑같을까요?
> 아니다. 이 둘의 성능은 다르다. `StringBuilder`는 동기화가 없기 때문에 단일 스레드 환경에서 더 빠르다. 반면, `StringBuffer`는 동기화로 인해 추가적인 오버헤드가 발생하므로 성능이 떨어진다. 따라서 단일 스레드 환경에서는 `StringBuilder`가 더 효율적이다. 

</details>

<details>
<summary style="font-size: 1.5em; font-weight: bold;">❓ 함정 질문</summary>

#### `synchronized` 키워드를 달면 내부적으로 어떤 일이 벌어지는지 동작 원리에 대해 알아보자.
> `synchronized` 키워드는 메서드나 블록에 적용되어 해당 코드 영역에 대한 접근을 제어한다.
> - **모니터 락(Monitor Lock)**: `synchronized`가 적용된 메서드나 블록에 접근하려는 스레드는 먼저 해당 객체의 모니터 락을 획득해야 한다. 이 락은 객체에 대한 독점적인 접근을 보장한다.
> - **대기 및 경쟁**: 한 스레드가 락을 획득하면 다른 스레드는 그 락이 해제될 때까지 대기해야 한다. 이로 인해 여러 스레드 간의 경쟁이 발생할 수 있다.
> - **스레드 안정성**: `synchronized`를 통해 메서드가 동시에 실행되지 않도록 보장하므로, 데이터의 일관성을 유지할 수 있다. 

이러한 동작 원리 때문에 `StringBuffer`는 멀티스레드 환경에서 안전하게 사용할 수 있지만, 성능이 떨어지는 단점이 있다.

</details>
</details>

<br>

<details>
<summary style="font-size: 1.5em; font-weight: bold;">System.out.println 메소드를 현업에서 쓰지 말라고 하는 이유가 무엇일까요?</summary>

### System.out.println 메서드를 현업에서 절대 쓰지 말라고 하는 이유
- **1. 성능 문제**: 
  - `System.out.println`은 콘솔에 출력을 수행하는 메서드로, 성능이 매우 저조하다. 이 메서드는 I/O 작업이 포함되므로, 출력이 발생할 때마다 시스템이 출력을 처리하는 데 시간이 걸린다.
  - 특히 대량의 데이터를 출력할 때, 이 메서드는 병목 현상을 일으킬 수 있다.
- **2. Blocking I/O**: 
  - `System.out.println`은 블로킹 I/O를 사용한다. 즉, 출력 작업이 완료될 때까지 호출한 스레드는 대기하게 된다. 이로 인해 다른 작업이 지연될 수 있다.
- **3. 스레드 안전성**:
  - `System.out.println`은 기본적으로 동기화되지 않아서 여러 스레드가 동시에 접근할 경우 출력 결과가 섞이는 경우가 발생할 수 있다. 이는 디버깅과 로깅에 문제를 일으킬 수 있다.

<details>
<summary style="font-size: 1.5em; font-weight: bold;">❓ 꼬리 질문</summary>

#### 성능 저하의 이유
> - **I/O 작업의 비용**: 콘솔 출력은 메모리 내에서 데이터를 처리하는 것보다 훨씬 느리다. I/O 작업이 발생할 때마다 커널과의 상호작용이 필요하기 때문에 성능이 저하된다.
> - **스레드 대기**: 블로킹 I/O는 스레드가 대기 상태로 전환되게 하여 CPU 자원이 효율적으로 사용되지 못하게 한다.

#### `synchronized` 키워드는 왜 현업에서 큰 성능 저하를 일으킬 수 있을까요?
> - **모니터 락 경합**: `synchronized` 키워드는 특정 코드 블록에 대한 접근을 제어한다. 여러 스레드가 동시에 해당 블록에 접근하려고 할 경우, 락을 획득하기 위해 대기해야 하므로 성능이 저하된다.
> - **대기 시간**: 락을 획득하기 위해 대기하는 동안 스레드는 CPU를 사용하지 않으므로, 전체적인 처리 성능이 저하된다.

#### Blacking I/O는 왜 성능을 저하시킬 수 있을까요?
> - **대기 상태**: 블로킹 I/O는 작업이 완료될 때까지 스레드를 대기 상태로 전환한다. 이로 인해 다른 작업이 수행되지 못하고, 시스템의 자원이 비효율적으로 사용된다.
> - **스레드 리소스 낭비**: 대기하는 스레드가 시스템 자원을 점유하게 되므로, 다른 스레드가 CPU를 사용하기 어렵게 만든다.

#### `synchronized`와 Blocking I/O가 만나면 어떻게 성능 하락을 초래할 수 있을까요?
> - **락 대기와 블로킹**: `synchronized` 블록 내에서 블로킹 I/O 작업이 발생하면, 해당 블로킹 I/O가 완료될 때까지 락을 획득한 스레드가 대기하게 된다. 다른 스레드가 락을 획득하려고 대기하는 동안, 블로킹 I/O가 진행 중인 스레드는 CPU를 사용하지 않게 된다.
> - **CPU 사용률 저하**: 이로 인해 CPU 사용률이 낮아지고, 전체 애플리케이션의 응답성이 저하될 수 있다.

</details>

### 시뮬레이션: 스레드 동작 및 CPU 사용률
1. 스레드 1이 `synchronized` 블록에 진입하고, 블로킹 I/O 작업을 수행한다고 가정한다.
2. 스레드 1이 블로킹 I/O 작업을 수행하는 동안, 스레드 2는 `synchronized` 블록에 접근하려고 대기한다.
3. 스레드 1이 블로킹 I/O로 인해 대기 상태에 있을 때, 스레드 2는 락을 획득하지 못하므로 대기한다.
4. 이로 인해 CPU 사용률이 낮아지고, 응답 시간은 증가한다.

결과적으로, `synchronized`와 블로킹 I/O가 결합되면 시스템의 성능이 크게 저하되고, 스레드 간의 경쟁 상태와 대기 상태가 발생하여 CPU 자원이 비효율적으로 사용된다.

</details>

<br>

<details>
<summary style="font-size: 1.5em; font-weight: bold;">ArrayList 는 내부적으로 어떻게 구현되어있을까요?</summary>
여기에 내용을 작성하세요.
</details>

<br>

<details>
<summary style="font-size: 1.5em; font-weight: bold;">스레드는 왜 써야하는 것일까요?</summary>

스레드는 프로세스 내에서 실행되는 경량의 실행 단위이다. 하나의 프로세스는 여러 개의 스레드를 가질 수 있으며, 이들은 자원을 공유하면서 동시에 작업을 수행할 수 있다.

- **1. 병렬 처리**: 스레드를 사용하면 여러 작업을 동시에 수행할 수 있다. 이는 CPU의 멀티코어 기능을 활용하여 성능을 극대화할 수 있게 해준다.
- **2. 자원 공유**: 스레드는 같은 프로세스 내에서 메모리 공간을 공유하므로, 스레드 간의 데이터 전송이 빠르고 효율적이다. 이로 인해 데이터 공유와 통신이 용이하며, 자원을 절약할 수 있다.
- **3. 응답성 향상**: GUI 애플리케이션에서 스레드를 사용하면 사용자 인터페이스가 블로킹되지 않고, 사용자와의 상호작용을 계속 유지할 수 있다.
- **4. 비동기 작업**: 스레드를 사용하여 비동기적으로 작업을 수행할 수 있다. 이는 작업 완료를 기다리지 않고 다른 작업을 계속 진행할 수 있게 해준다.
- **5. 성능 향상**: CPU 바운드 작업이나 I/O 바운드 작업에서 스레드를 사용하면 성능을 최적화할 수 있다. 특히, I/O 작업은 대기 시간이 길기 때문에 다른 스레드가 실행될 수 있도록 하여 자원을 효율적으로 사용할 수 있다.

> 스레드는 병렬 처리, 자원 공유, 응답성 향상 등 다양한 장점을 제공하여 프로그램의 성능과 효율성을 높이는 데 중요한 역할을 한다. 하지만 스레드 사용 시 동기화 문제, 데드락과 같은 복잡성이 증가할 수 있으므로 적절한 설계가 필요하다.

</details>

<br>

<details>
<summary style="font-size: 1.5em; font-weight: bold;">0이 들어있는 변수에 10개의 스레드가 동시에 접근해서 ++ 연산을 하면 우리 예상과 다르게 10이 나오지 않습니다. 왜 그럴까요?</summary>

- **1. 원자성 부족**: ++ 연산은 실제로 두 개의 작업으로 구성된다. 첫째, 현재 값을 읽고, 둘째, 그 값을 1 증가시킨 후 다시 저장하는 과정이다. 해당 과정이 원자적이지 않기 때문에, 여러 스레드가 동시에 같은 변수를 읽고 수정할 경우, 서로의 작업이 겹칠 수 있다.
- **2. 경쟁 조건(Race Condition)**: 여러 스레드가 동시에 같은 변수를 수정하는 경우, 어떤 스레드가 먼저 실행될지 예측할 수 없다. 예를 들어, 스레드 A가 변수를 읽은 후, 스레드 B가 같은 변수를 읽고 1을 더한 후 저장할 수 있다. 이 경우, 두 스레드 모두 원래의 값인 0을 읽었기 때문에 최종적으로 1만 증가하게 된다.
- **3. 결과의 비결정성**: 스레드의 실행 순서는 운영체제에 의해 관리되며, 이는 예측할 수 없는 결과를 초래한다. 각 스레드가 ++ 연산을 수행할 때, 실행 순서에 따라 결과가 달라질 수 있다.

따라서 해당 문제를 해결하기 위해 synchronized 키워드나 AtomicInteger와 같은 동기화 메커니즘을 사용할 수 있다. 이렇게 하면 동시에 접근하는 스레드가 없도록 하여 원자적인 연산을 보장할 수 있다.

</details>

<br>

<details>
<summary style="font-size: 1.5em; font-weight: bold;">자바에서 동시성과 관련된 예약어를 모두 말씀해주세요.</summary>

</details>

<br>

<details>
<summary style="font-size: 1.5em; font-weight: bold;">Blocking IO와 Non-Blocking IO 의 차이를 말씀해주세요.</summary>

</details>

<br>

<details>
<summary style="font-size: 1.5em; font-weight: bold;">Serializable 은 무엇일까요?</summary>

</details>
