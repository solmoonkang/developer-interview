# 01. JAVA

- [1. 객체지향 프로그래밍의 기본 개념](#1-객체지향-프로그래밍의-기본-개념)
    - [객체지향 프로그래밍의 4가지 특징](#추상화-abstraction)
    - [SOLID 5원칙](#객체지향-설계의-5가지-원칙-solid)
    - [객체지향, 절차지향, 함수형 프로그래밍의 차이점](#프로그래밍-패러다임이란)
    - [추상 클래스와 인터페이스의 차이점](#추상-클래스abstract-class-란)
- [2. Java의 기본 개념](#2-java-기본-개념)
  - [원시형과 참조형의 차이점](#원시타입-vs-참조타입)
  - [static 키워드란](#static의-메모리)
  - [final 키워드란](#final-키워드란)
  - [generic 개념](#제네릭generic-이란)
  - [Java Stream 개념](#stream-이란)
  - [Java Lambda 표현식](#람다lambda-vs-람다-표현식lambda-expression)
  - [Reflection 개념](#reflection의-주요-개념)
- [3. Java의 컬렉션 프레임워크](#3-java의-컬렉션-프레임워크)
  - [List, Set, Map 인터페이스](#list-인터페이스란)
  - [ArrayList, HashSet, HashMap 구현체]()
  - [Iterator 사용법](#iterator-란)
- [4. Java의 예외 처리](#4-java의-예외-처리)
  - [Exception의 종류(Checked, Unchecked)](#checked-exception)
  - [try-catch-finally 블록](#try-catch-finally-블록이란)
  - [사용자 정의 예외](#사용자-정의-예외-클래스-생성)
- [5. 멀티스레딩](#5-멀티스레딩)
  - [스레드의 개념](#스레드란)
  - [Runnable 인터페이스와 Thread 클래스](#runnable-인터페이스와-thread-클래스란)
  - [동기화 및 Lock]()
- [6. Java 메모리 관리](#6-java-메모리-관리)
  - [가비지 컬렉션(Garbage Collection)]()
  - [Heap과 Stack 메모리 구조]()
- [7. JVM, JRE, JDK](#7-jvm-jre-jdk)
  - [JVM의 역할](#jvm이란)
  - [JRE와 JDK의 차이점](#jre란)

---

## 1. 객체지향 프로그래밍의 기본 개념

<details>
<summary style="font-size: 1.5em; font-weight: bold;">객체지향 프로그래밍의 4가지 특징</summary>

### 추상화 (Abstraction)
> 객체들이 공통적으로 필요로 하는 속성이나 동작을 하나로 추출해 내는 작업

즉, 알고는 있지만, 정확하게 표현하기 힘든 것들을 중요한 부분이나 특징점으로 잡아 설명하는 것을 추상화한다고 할 수 있다.
프로그래밍에서 추상화는 클래스를 정의할 때 불필요한 부분들을 생략하고 객체의 속성 중 중요한 것에만 중점을 두어 개략화하는 것을 말한다.

예를 들면, 삼성폰과 아이폰이라는 객체가 있을 때, 이 객체들을 하나로 묶을 때 공통적인 특징을 휴대폰으로 묶어서 이름을 붙이는 것을 추상화하고 할 수 있다.
이처럼 공통된 기능을 휴대폰에서 미리 구현을 하고, 상속을 통해서 공통된 기능을 삼성폰과 아이폰에 이어주면 삼성폰과 아이폰은 각자의 고유기능을 집중적으로 개발할 수 있다.
이럴 경우, 공통된 기능을 다시 정의할 필요가 없어 코드의 중복이 줄어들고, 코드의 재사용성이 용이해지는 장점이 있다.

> 즉, 추상화로 구현을 하면 새로운 객체를 만들 때 클래스의 고유기능만 새로 만들어주고, 공통된 기능은 상속을 통해서 이용이 가능하다.

### 상속 (Inheritance)
> 여러 개체들이 지닌 공통된 특성을 추출하여 하나의 개념이나 법칙으로 성립하는 과정이

예를 들어, 삼성폰과 아이폰은 모두 휴대폰이자 통신기기이며 전자제품이라는 공통적인 속성을 가지고 있다. 이처럼 삼성폰 & 아이폰, 휴대폰, 통신기기, 전자제품은 중복된 속성을 포함하고 있다.
이러한 속성들을 각 클래스마다 개별적으로 정의하기보다는, 공통된 속성들을 하나의 클래스로 묶어 상속을 통해 재사용하는 것이 훨씬 효율적인 프로그래밍 방법이다.

상속을 통해 하위 클래스는 상위 클래스의 변수와 메서드를 물려받아 재사용할 수 있다. 이로 인해 코드의 중복을 줄이고, 유지보수성을 높일 수 있다.

### 다형성 (Polymorphism)
> 프로그래밍에서의 다형성이란 같은 자료형에 여러가지 타입의 데이터를 대입하여 다양한 결과를 얻어낼 수 있는 성질을 의미

비유적으로 표현하자면, 한 명의 남자는 특정 상황에서 여러 가지 역할을 수행한다. 누군가에게는 친구, 자식에게는 아버지, 동아리에서는 리더, 아내에게는 남편, 부모님에게는 자식이 될 수 있다.
이처럼 객체도 상황에 따라 여러가지 형태를 가질 수 있다는 것이 다형성의 핵심이다. 대표적인 예로는 `메서드 오버라이딩`과 `메서드 오버로딩`이 있다.

#### 💡 메서드 오버라이딩 (Overriding)
- 부모 클래스의 메서드를 자식 클래스에서 재정의해서 사용하는 것을 의미한다. 자식 클래스는 부모 클래스의 메서드를 재활용하면서 독자적인 기능을 추가할 수 있다.

#### 💡 메서드 오버로딩 (Overloading)
- 같은 이름의 메서드를 다양한 매개변수 타입과 개수로 정의하는 것을 의미한다. 오버로딩은 메서드 이름을 동일하게 유지하면서도 다양한 상황에서 유연하게 대응할 수 있는 방법을 제공한다.

적절하게 다형성을 활용하면 코드의 재사용성과 유연성을 높이고, 불필요한 코드 중복과 결합도를 낮춰서 유지보수성을 높일 수 있다. 그러나 무분별한 오버로딩은 코드의 동작을 이해하는 데 어려움을 줄 수 있으므로, 적절한 사용이 필요하다.

### 캡슐화 (Encapsultation)
> 객체지향에서의 캡슐화는 데이터와 메서드를 하나의 단위로 묶어 외부에서 접근하지 못하도록 보호하는 개념

예를 들어, 알약은 그 안에 어떤 구성물질이 들어 있는지 알 수 없으며, 내용물은 캡슐을 통해서 안전하게 보호된다. 이처럼 캡슐화는 외부에서 알 필요가 없는 부분을 감춤으로써 대상을 단순화하는 추상화의 한 형태이다.

#### 💡 캡슐화를 해야 하는 이유
- **데이터 보호**:
  - 외부로부터 클래스에 정의된 속성과 기능들을 보호한다.
- **데이터 은닉**:
  - 내부의 동작을 감추고 외부에는 필요한 부분만 노출한다.

캡슐화가 중요한 이유는 불안정한 부분과 안정적인 부분을 분리하여 변경의 영향을 통제할 수 있기 때문이다. 불안정한 부분은 객체 내부로 추상화해서 변경을 최소화하고, 안정적인 부분은 외부에 공개한다. 
이렇게 객체의 외부와 내부를 구분하면 구현 변경의 폭이 넓이지고, 변경의 영향을 효과적으로 관리할 수 있다. 또한, 캡슐화를 통해 코드 작성 이후의 추가 요구사항에도 유연하게 대처할 수 있다.

</details>

<br>

<details>
<summary style="font-size: 1.5em; font-weight: bold;">SOLID 5원칙</summary>

### 객체지향 설계의 5가지 원칙, SOLID

**SOLID**는 `SRP(단일 책임)`, `OCP(개방-폐쇄)`, `LSP(리스코프 치환)`, `ISP(인터페이스 분리)`, `DIP(의존 역전)`로, SOLID 원칙을 지키면 시간이 지나도 변경이 용이하고, 유지보수와 확장이 쉬운 소프트웨어를 개발하는데 도움이 된다.

#### SRP (Single Responsibility Principle): 단일 책임 원칙

`단일 책임 원칙(SRP)`은 하나의 클래스가 오직 하나의 책임만 가져야 한다는 원칙이다. 즉, 클래스는 하나의 기능에 대해 변경이 필요할 때만 수정되어야 하며, 이는 유지보수의 효율성을 높인다.

> - **책임의 정의**: 클래스가 수행하는 기능을 의미한다.
> - **변경 이유**: 클래스의 변경 이유는 단 하나여야 하며, 이를 통해 파급 효과를 최소화할 수 있다.
> - **유지보수 효율성**: 여러 책임을 가진 클래스는 서로 영향을 주어 유지보수가 비효율적이 된다.
> - **응집도와 결합도**: 높은 응집도와 낮은 결합도를 유지해야 하며, 이를 통해 코드의 품질을 높일 수 있다.

예를 들어, 하나의 클래스가 여러 기능을 수행하면, 내부 함수 간의 결합도가 높아져 코드 효율성이 떨어질 수 있다. 따라서 각 클래스는 명확한 책임을 가져야 한다.

#### OCP (Open-Closed Principle): 개방-폐쇄 원칙

`개방-폐쇄 원칙(OCP)`은 소프트웨어 요소가 **확장에는 열려 있으나 변경에는 닫혀 있어야 한다**는 원칙이다. 즉, 기존 코드를 수정하지 않고도 기능을 추가하거나 변경할 수 있도록 설계해야 한다.

> - **기능 수정**: 새로운 클래스를 생성하여 기존 인터페이스를 구현함으로써 기능을 확장할 수 있다.
> - **유지보수 간소화**: 특정 모듈의 기능을 수정할 때, 해당 모듈을 사용하는 모든 모듈을 수정할 필요가 없어 유지보수가 간편해진다.
> - **장점**: OCP를 지키면 유연성, 재사용성, 유지보수성을 극대화할 수 있다.

OCP를 구현하기 위해서는 기존 코드를 변경하지 않고 기능을 수정하거나 추가하기 위해서 `상속(다형성)`과 `추상화(인터페이스)`를 활용해야 한다. 자주 변경되는 부분을 추상화하여 기존 코드의 수정을 최소화하고, 기능 확장을 용이하게 한다.

#### LSP (Liskov Substitution Principle): 리스코프 치환 원칙

`리스코프 치환 원칙(LSP)`은 하위 타입 객체가 상위 타입 객체에서 가능한 모든 행위를 수행할 수 있어야 한다는 원칙이다. 즉, 상위 타입 객체를 하위 타입 객체로 대체해도 프로그램이 정상적으로 동작해야 한다.

> - **다형성 준수**: 하위 클래스는 상위 클래스와 인터페이스 규약을 모두 지켜야 한다.
> - **IS-A 관계**: 상속 관계에서는 일반환 관계(IS-A)가 반드시 성립해야 한다. 상속 관계가 아닌 클래스들 간의 상속은 LSP를 위반하게 된다.

예를 들어, 자동차 인터페이스가 있을 때, 액셀 기능은 자동차가 앞으로 이동해야 한다. 만약, 액셀 기능을 실행했을 때 자동차가 뒤로 간다면, 이는 LSP를 위반하는 것이다.
기능의 성능이 느리더라도, 액셀을 눌렀을 때 자동차는 항상 앞으로 가야 한다.

또한, LSP를 위반하면 OCP도 위반하게 되므로, 상속 관계를 명확히 정의하여 LSP를 준수하도록 설계해야 한다.

#### ISP (Interface Segregation Principle): 인터페이스 분리 원칙

`인터페이스 분리 원칙(ISP)`은 클라이언트가 자신이 사용하는 메서드에만 의존해야 한다는 원칙이다. 즉, 특정 클라이언트를 위한 여러 개의 인터페이스가 범용 인터페이스 하나보다 더 유리하다.

> - **세분화된 인터페이스**: 인터페이스는 클라이언트를 기준으로 잘게 나누어야 한다. 예를 들어, '자동차'라는 범용 인터페이스 대신 운전, 정비, 타이어 등의 세부 인터페이스로 나누는 것이 더 효과적이다.
> - **유지보수 용이성**: 세부적인 인터페이스로 나누면 특정 기능(예를 들어, 타이어 교체)에 대한 변경 시 해당 인터페이스만 확인하고 수정하면 된다.
> - **대체 가능성 증가**: 인터페이스가 명확해지고, 기능의 대체 가능성이 높아진다.

클라이언트가 필요로 하는 인터페이스를 분리함으로써, 클라이언트가 사용하지 않는 인터페이스에 변경이 발생하더라도 다른 인터페이스에는 영향을 주지 않도록 하는 것이 ISP의 핵심이다.

#### DIP (Dependency Inversion Principle): 의존 역전 원칙

`의존 역전 원칙(DIP)`은 "프로그래머는 구체화에 의존해서는 안 되고, 추상화에 의존해야 한다"는 원칙이다. 의존성 주입은 이를 실현하는 방법 중 하나이다.

> - **추상화에 의존**: 변하기 쉬운 구체적인 것보다는 변하기 어려운 추상적인 것에 의존해야 한다. 즉, 구현 클래스가 아니라 인터페이스에 의존해야 한다.
> - **유연한 구현체 변경**: 클라이언트가 인터페이스에 의존하면 구현체를 유연하게 변경할 수 있다. 반면, 구현체에 의존하면 변경이 어려워진다.
> - **모듈 간의 독립성**: 고수준 모듈은 저수준 모듈의 구현에 의존해서는 안 된다. 저수준 모듈이 변경되더라도 고수준 모듈은 영향을 받지 않는 구조가 이상적이다.

해당 원칙을 따르면 시스템의 유연성과 유지보수성이 향상된다. 의존성을 추상화하여 모듈 간의 결합도를 낮추는 것이 핵심이다.

</details>

<br>

<details>
<summary style="font-size: 1.5em; font-weight: bold;">객체지향, 절차지향, 함수형 프로그래밍의 차이점</summary>

### 프로그래밍 패러다임이란?

프로그래밍 패러다임은 프로그래머에게 프로그래밍 관점을 가지게 하고 코드를 어떻게 작성할지 결정하는 역할을 한다.

즉, 새로운 프로그래밍 패러다임을 통해서 새로운 방식으로 생각하는 방법을 배우게 되고, 이를 바탕으로 코드를 구현하게 된다.

현재까지의 프로그래밍 패러다임: 절차지향 -> 객체지향 -> 함수형
- **명령형 프로그래밍**: 무엇(What)을 할 건지를 나타내기보다 어떻게(How) 할 건지를 설명하는 방식이다.
  - `절차지향 프로그래밍`: 수행되어야 할 기능을 순차적인 처리 과정으로 진행하는 방식이다.
  - `객체지향 프로그래밍`: 객체들의 집합으로 프로그램의 상호작용으로 진행하는 방식이다.
- **선언형 프로그래밍**: 어떻게(How) 할 건지를 나타내기보다 무엇(What)을 할 건지를 설명하는 방식이다.
  - `함수형 프로그래밍`: 순수 함수를 조합하여 소프트웨어를 만드는 방식이다.

### 절차지향, 객체지향, 함수형 프로그래밍
#### 절차지향 프로그래밍 (Procedural Programming)
> 순차적인 처리를 중요하게 여기며, 프로그램 전체가 유기적으로 연결되도록 만드는 프로그래밍 기법이다.

절차지향 프로그래밍의 장점: 
- 코드의 가독성이 좋다.
- 코드를 단위화할 수 있다.
- 컴퓨터의 처리구조와 비슷해 실행 속도가 빠르다.

절차지향 프로그래밍의 단점: 
- 각각의 코드가 순서에 따라 실행되어, 변경과 유지보수 및 분석이 어렵다.
- 변수나 상수 등의 값들을 관리하는 자료형과 해당 자료형을 사용하는 함수가 분리되어 사용된다.

대표적인 절차지향 프로그래밍 언어는 `C`언어 등이 있다.

#### 객체지향 프로그래밍 (Object-Oriented Programming)
> 모든 데이터를 객체로 취급하여 객체가 처리 요청을 받았을 때 객체 내부에 있는 기능을 가져와 사용하여 처리하는 프로그래밍 기법으로, 
> 모든 객체가 내부의 자료형(Field)과 함수(Method)로 구성된 프로그래밍 구조를 의미한다.

객체지향 프로그래밍의 장점: 
- 코드의 재사용이 가능하여 유지보수가 용이하다.
- 분석과 설계의 전환이 쉽다.

객체지향 프로그래밍의 단점:
- 처리 속도가 상대적으로 느리다.
- 설계에 많은 시간이 소요된다.

대표적인 객체지향 프로그래밍 언어는 `Java`와 `Python` 등이 있다.

#### 함수형 프로그래밍 (Functional Programming)
> 순수 함수를 사용하여 상태를 제어하기보단 빠르게 처리하는데 초점을 둔 프로그래밍 기법으로, 
> 실행 순서를 지정할 필요가 없어 비절차형 언어라고도 한다.

함수형 프로그래밍의 장점: 
- 코드에서 프로그램의 실행에 영향을 미치는 영역과 순수한 영역을 최대한 분리한다.
- 코드의 가독성이 높아지고, 유지보수가 좋아진다.
- 테스트가 쉬워진다.

함수형 프로그래밍의 단점:
- 외부 데이터 혹은 내부 데이터의 상태를 조작할 수 없다.

대표적인 함수형 프로그래밍 언어는 `Haskell`과 `OCamal` 등이 있다.

##### 💡 순수 함수란?
> 동일한 입력 값을 넣었을 때, 동일한 리턴 값을 반환하며 외부에 영향을 받지 않는 함수로 함수의 실행이 프로그램에 영향을 주지 않는다.
> 때문에 비상태 불변성(전달된 데이터를 변경하는 것이 아닌, 새로운 버전이나 오브젝트를 만들어 결과 값으로 전달)을 유지하고 여러 가지 동시다발적인 멀티스레딩 환경에서도 안정적으로 동작할 수 있다.

### 절차지향 프로그래밍 vs 객체지향 프로그래밍
절차지향 프로그래밍 위에 객체지향 프로그래밍이 탄생한 것으로, 절차지향 프로그래밍이 갖는 부족함을 객체지향 프로그래밍이 보완해주는 역할을 한다.

> 절차지향 프로그래밍은 함수가 있고, 객체지향 프로그래밍 또한 함수가 있지만 `객체`라는 개념이 등장한다.

### 함수형 프로그래밍 vs 객체지향 프로그래밍
#### 1. 함수형 프로그래밍은 함수 자체가 `일급 객체`가 되지만, 객체지향 프로그래밍은 클래스(혹은 객체)가 `일급 객체`가 된다.

##### 💡 일급 객체란?
> 다른 요소들과 아무런 차별이 없는 객체로, 함수의 인자로도 넘겨질 수 있고 변수에 대입도 가능한 객체를 의미한다.

#### 2. 객체지향 프로그램에서는 프로그램을 상호작용하는 객체들의 집합으로 볼 수 있지만, 함수형 프로그래밍에서는 상태 값을 지니지 않은 함수들의 연속으로 볼 수 있다.

##### 객체지향 프로그래밍의 경우
> 클래스 디자인과 객체들의 관계를 중심으로 코드 작성이 이루어진다. 따라서 상태, 멤버변수, 메서드 등이 긴밀한 관계를 가지고 있다.
> 특히, 멤버변수가 어떤 상태를 가지고 있는가에 따라서 결과가 달라진다.

##### 함수형 프로그래밍의 경우
> 값의 연산 및 결과 도출 중심으로 코드 작성이 이루어진다. 함수는 인자로 받은 값을 별도로 저장하지 않고, 간결한 과정으로 처리하고 매핑하는 데 주 목적을 둔다.

</details>

<br>

<details>
<summary style="font-size: 1.5em; font-weight: bold;">추상 클래스 vs 인터페이스</summary>

### 추상 클래스(Abstract Class) 란?
추상 클래스는 객체지향 프로그래밍에서 사용되는 클래스의 일종으로, 하나 이상의 추상 메서드를 포함하는 클래스이다.

#### 💡 추상 메서드(Abstract Method) 란?
> 추상 메서드는 메서드의 시그니처(이름, 매개변수, 반환 타입)는 정의되어 있지만, 구체적인 구현은 제공되지 않는다.
 
추상 클래스는 인스턴스를 생성할 수 없으며, 주로 다른 클래스가 상속받아 사용한다.

예를 들어 설명하면 A와 B가 있을 때, A는 웃을 때 덧니가 보이고 B는 웃을 때 입을 가리고 웃는다. 각자 자기 스타일대로 웃고 있지만, 이들은 모두 웃는다는 액션을 하고 있다.
여기서 웃는다는 공통적인 액션을 추상 클래스에 넣는 것이다.

> 실체 클래스는 실체가 드러는 클래스이며, 추상 클래스는 실체 클래스의 공통적인 부분을 추출해 어느정도 규격을 잡아놓은 추상적인 클래스이다.
> 그래서 실체 클래스는 실제 객체를 생성할 정도의 구체성을 갖는 반면, 추상 클래스는 아직 메서드와 내용이 추상적이기 때문에 객체를 생성할 수 없게 만들었다.

### 추상 클래스의 사용 용도

1. **코드 재사용성**: 공통적인 기능이나 속성을 정의하여 여러 클래스에서 재사용할 수 있다.
2. **기본 구현 제공**: 기본적인 메서드 구현을 제공하고, 자식 클래스에서 필요에 따라 오버라이드해서 사용할 수 있다.
3. **설계의 명확성**: 추상 클래스를 통해 클래스 간 관계를 명확히 하고, 공통된 인터페이스를 정의하여 코드의 구조를 이해하기 쉽게 만든다.

### 인터페이스(Interface) 란?

### 인터페이스의 사용 용도

</details>

---

## 2. Java 기본 개념

<details>
<summary style="font-size: 1.5em; font-weight: bold;">원시형(Primitive Type) vs 참조형(Reference Type)</summary>

### 원시 타입이란?
원시 타입은 Java에서 기본적으로 제공하는 데이터 타입으로, 실제 값을 직접 저장한다. 예를 들어, `int`, `boolean`, `char` 등이 있다.

### 참조 타입이란?
참조 타입은 객체를 참조하는 데이터 타입으로, 실제 데이터는 힙 메모리에 저장되고, 변수는 그 데이터의 메모리 주소를 저장한다. 예를 들어, `String`, 배열, 사용자 정의 클래스 등이 있다.

> 원시 타입의 변수는 실제 값을 변수 안에 저장하지만, 참조 타입의 변수는 메모리의 번지를 변수 안에 저장하여 저장된 메모리 주소 값을 통해 객체를 참조한다.

### 원시타입 vs 참조타입
#### 1. NULL
- 원시 타입은 Null을 담을 수 없으나, 참조 타입은 Null을 입력값으로 받을 수 있다.

```java
int i = null; // 불가능
Integer integer = null; // 가능
```

#### 2. 제네릭 타입
- 원시 타입은 제네릭 타입에서 사용할 수 없으나, 참조 타입은 제네릭 타입에서 사용할 수 있다.
```java
List<int> i; // 불가능
List<Integer> integer; // 가능
```

#### 3. 접근 속도, 메모리 양
원시 타입은 Null을 다루지 못하고, 제네릭에 담기지 못하지만, 원시 타입을 참조 타입과 비교해서 갖는 장점은 성능상의 이점이 존재한다.

- **접근 속도**: 
  - 원시 타입은 `스택` 메모리에 값이 존재하는 반면, 참조 타입은 하나의 인스턴스이므로 스택 메모리에는 참조값만 있고, 실제 값은 `힙` 메모리에 존재한다.
  - 참조 타입은 값을 필요로 할 때마다 언박싱(Unboxing) 과정을 거쳐야 하므로 원시 타입과 비교했을 때 접근 속도가 느리다.
- **메모리 양**: 
  - 원시 타입은 메모리를 적게 차지하는 반면, 참조 타입은 훨씬 많은 메모리를 사용한다.

##### 💡 박싱(Boxing) & 언박싱(Unboxing)
박싱(Boxing)은 원시 타입을 참조 타입으로 변환시키는 것을 의미하며, 언박싱(Unboxing)은 참조 타입을 원시 타입으로 변환시키는 것을 의미한다.

박싱은 값 타입을 참조 타입으로 변환하여 값을 포함하는 객체를 힙에 생성하는 것이며, 언박싱은 박싱된 참조 타입으로부터 원래의 값을 다시 추출하는 연산을 의미한다.

Java 1.5 이전에는 모두 변환 과정을 거쳐야 했지만, 자바 1.5부터 추가된 Auto Boxing/Unboxing 기능으로 아래의 예시와 같이 명시적으로 원시 타입을 참조 타입으로 감싸지 않아도 자동으로 변환된다.
```java
int i = 15;
Integer integer = i;
```

> 그러나, Auto Boxing/Unboxing 기능은 컴파일러 내부적으로 추가 연산작업을 거치게 되어 메모리 누수의 원인이 될 수 있다.
> 따라서, 성능 향상을 위해서 Auto Boxing/Unboxing이 일어나지 않도록 동일한 타입 연산이 이루어지도록 구현하는 것이 좋다.

</details>

<br>

<details>
<summary style="font-size: 1.5em; font-weight: bold;">staic 키워드란?</summary>

### Static의 메모리
Java에서 `static` 키워드를 사용한다는 것은 메모리에 한 번 할당되어 프로그램이 종료될 때 해제되는 것을 의미한다.

일반적으로 우리가 만든 클래스는 Static 영역에 생성되고, new 연산을 통해 생성한 객체는 Heap 영역에 생성된다.
- 객체의 생성 시 할당된 Heap 영역의 메모리는 GC(Garbage Collector)를 통해 수시로 관리를 받는다. 
- 반면, static 키워드를 통해 Static 영역에 할당된 메모리는 모든 객체가 공유하는 메모리라는 장점이 있지만, GC의 관리 영역 밖에 존재하므로 static을 자주 사용하면 프로그램 종료 시까지 메모리가 할당된 채로 존재하므로 시스템의 퍼포먼스에 악영향을 주게 된다.

### static 변수의 특징
- static 변수는 클래스 변수이다.
- 객체를 생성하지 않고도 static 자원에 접근이 가능하다.

> static 변수와 static 메서드는 static 메모리 영역에 존재하므로 객체가 생성되기 이전에 이미 할당되어 있다. 때문에, 객체의 생성없이 바로 접근(사용)이 가능하다.

</details>

<br>

<details>
<summary style="font-size: 1.5em; font-weight: bold;">final 키워드란?</summary>

### final 키워드란?
Java에서 `final` 키워드를 사용한다는 것은 처음 정의된 상태가 변하지 않는 것을 보장한다는 불변성을 의미한다.

### 1. final 변수
Java에서 변수들은 기본적으로 가변적인데, 변수에 `final` 키워드를 붙이면 참조값을 변경하지 못하므로 불변성을 확보할 수 있다.
```java
final String name = "solmoon";
```

`final` 키워드가 붙은 변수는 초기화한 후 변경할 수 없다. 변경을 할 경우 다음과 같이 컴파일 에러가 발생한다.
```java
final String name = "solmoon";
name = "gildong";  // ⚠️ COMPILE ERROR!
```

### 2. final 인자
`final` 키워드가 붙은 인자는 메서드 내에서 변경이 불가능하다. 따라서 다음과 같이 final int로 선언한 number 변수는 읽을 수 있지만, number = 2처럼 값을 변경할 경우에는 컴파일 에러가 발생한다.
```java
public void func(final int number) {
    System.out.println(number);
    number = 2;  // ⚠️ COMPILE ERROR!
}
```

### 3. final 클래스
클래스에 `final` 키워드를 붙이면 다른 클래스가 상속할 수 없는 클래스가 된다. 다음과 같이 final 클래스를 상속할 경우에는 컴파일 에러가 발생한다.
```java
final class FirstExample {
    final String hello;
    Example() { hello = "hello"; }
}

class SecondExample extends FirstExample() { // ⚠️ COMPILE ERROR! }
```

### 4. final 메서드
`final` 키워드가 붙은 메서드는 오버라이드(Override)가 불가능하다. 다음과 같이 FirstExample 클래스를 상속하는 SecondExample 클래스에서 getHello( )를 재정의할 수 없다. 오버라이드를 할 경우에는 컴파일 에러가 발생한다.
```java
class FirstExample {
    final String hello = "hello";
    final String getHello() { return hello; }
}

class FirstExample extends SecondExample {

  @Override
  String getHello() { // ⚠️ COMPILE ERROR!
    return "See you next time!";
  }
}
```
#### ⚠️ 주의할 점
`final` 변수는 초기화 이후 값 변경이 발생하지 않도록 만든다.
```java
final List<String> list = new ArrayList<>();
list.add("CHEER"); // ⚠️ COMPILE ERROR!
list.add("UP"); // ⚠️ COMPILE ERROR!
```

위와 같이 List에 `final` 키워드를 붙여 선언하면 list 변수의 변경은 불가능하다. 하지만, list 내부에 있는 변수들은 변경이 가능하여 문자열을 계속해서 추가할 수 있다.

#### 💡 Effective final 키워드
`Effective final` 키워드는 Java 8에서 추가된 기능으로, `final` 키워드가 붙지 않은 변수의 값이 변경되지 않는다면 해당 변수를 `Effective final`이라고 한다. final을 붙이지 않았지만 컴파일러가 final로 취급하는 것이다.
```java
int num = 1;

Runnable runnable = new Runnable() {
    @Override
    public void run() {
        System.out.println("number: " + num);
    }
};
runnable.run();
```

위 코드에서 변수 num은 `Effective final`이다. num 변수는 선언과 동시에 1로 할당되었고, 객체가 소멸될 때까지 값이 변경되지 않았기 때문이다.

Effective final이 없었던 Java 8 이전에는 run( ) 안에서 변경이 가능한 num 변수에 접근하기 떄문에 컴파일 에러가 발생하는 코드였다. 
하지만 Java 8은 num 변수가 내부에서 변경되지 않았기 때문에 final로 취급하여 컴파일 에러가 발생하지 않는다.

</details>

<br>

<details>
<summary style="font-size: 1.5em; font-weight: bold;">Generic 이란?</summary>

### 제네릭(Generic) 이란?
Java에서 제네릭(Generic)은 클래스, 인터페이스, 메서드에 타입 매개변수를 사용하는 기능으로, 코드의 재사용성을 높이고 타입 안전성을 강화하는 데 도움을 준다.
> 즉, 제네릭을 사용하면 다양한 데이터 타입을 처리할 수 있는 유연한 코드를 작성할 수 있다.

### 제네릭의 주요 특징
1. **타입 안전성**: 
   - 제네릭을 사용하면 컴파일 시 타입 체크가 이루어지므로, 잘못된 타입의 객체를 사용할 경우 컴파일 에러가 발생한다. 이는 런타임 오류를 줄이는 데 도움이 된다.
2. **코드 재사용성**: 
   - 제네릭을 사용하면 동일한 코드를 다양한 데이터 타입에 대해 사용할 수 있다. 
   - 예를 들어, 같은 알고리즘을 정수, 문자열 등 여러 타입에 적용할 수 있다.
3. **타입 매개변수**:
   - 제네릭은 타입 매개변수를 사용하여 클래스를 정의한다.
   - 일반적으로 대문자 `T`, `E`, `K`, `V` 등을 사용하여 타입 매개변수를 나타낸다.

### 제네릭의 사용 예시
#### 1. 제네릭 클래스
```java
class Box<T> {
    private T item;

    public void setItem(T item) {
        this.item = item;
    }

    public T getItem() {
        return item;
    }
}

public class Main {
    public static void main(String[] args) {
        Box<String> stringBox = new Box<>();
        stringBox.setItem("Hello");
        System.out.println(stringBox.getItem()); // Hello

        Box<Integer> integerBox = new Box<>();
        integerBox.setItem(123);
        System.out.println(integerBox.getItem()); // 123
    }
}
```
해당 예시에서 Box<T>는 제네릭 클래스로, `T`는 타입 매개변수이다. 이를 통해 Box 클래스를 다양한 타입으로 사용할 수 있다.

#### 2. 제네릭 메서드
```java
public class GenericMethod {
    public static <T> void printArray(T[] array) {
        for (T element : array) {
            System.out.println(element);
        }
    }

    public static void main(String[] args) {
        Integer[] intArray = {1, 2, 3};
        String[] strArray = {"A", "B", "C"};

        printArray(intArray); // 1 2 3
        printArray(strArray); // A B C
    }
}
```
해당 예시에서 printArray 메서드는 제네릭 메서드로, 어떤 타입의 배열이든 받을 수 있다.

> Java의 제네릭은 타입 매개변수를 사용하여 클래스, 메서드, 인터페이스 등을 정의할 수 있게 해주며, 이를 통해 타입 안전성을 높이고 코드의 재사용성을 증가시킨다.
> 제네릭을 사용하면 다양한 데이터 타입을 처리할 수 있는 유연한 코드를 작성할 수 있다.

</details>

<br>

<details>
<summary style="font-size: 1.5em; font-weight: bold;">Java Stream 이란?</summary>

### Stream 이란?
Java에서 스트림(Stream)은 데이터의 연속적인 흐름을 처리하기 위한 추상화된 개념으로, 주로 컬렉션(예로 List, Set)이나 배열과 같은 데이터 소스에 대해 간편하고 효율적인 데이터 처리 및 변환을 가능하게 한다.
Java 8부터 도입된 Stream API는 선언적 프로그래밍 스타일을 지원하여, 데이터 처리 과정을 더 간결하고 가독성 높게 작성할 수 있도록 해준다.

### Stream과 Stream API의 차이
- **Stream**: 
  - 데이터의 흐름을 처리하는 추상적인 개념으로, 데이터 소스(예로 배열, 컬렉션)에서 연속적으로 데이터를 읽고 처리하는 방법을 나타낸다.
  - 스트림은 데이터를 필터링, 매핑, 집계 등의 방식으로 처리할 수 있는 연산을 제공한다.
- **Stream API**: 
  - Java 8에서 도입된 API로, 스트림을 생성하고 처리하기 위한 구체적인 메서드와 인터페이스를 제공한다.
  - 예를 들어, `stream( )`, `filter( )`, `map( )`, `collect( )` 등의 메서드가 포함되어 있다.

### 스트림의 주요 특징
1. **데이터 소스**: 스트림은 컬렉션, 배열, I/O 채널 등 다양한 데이터 소스에서 생성될 수 있다.
2. **파이프라인**: 스트림은 여러 연산을 체인처럼 연결하여 사용할 수 있다. 이러한 연산은 중간 연산과 최종 연산으로 나뉜다.
   - **중간 연산**: 스트림을 변환하는 연산으로, 필터링, 매핑, 정렬 등이 있다. 중간 연산은 스트림을 반환하며, 여러 개의 중간 연산을 연결할 수 있다.
   - **최종 연산**: 스트림의 처리를 종료하고 결과를 반환하는 연산으로, `forEach`, `collect`, `reduce` 등이 있다. 최종 연산이 호출되면 스트림의 처리가 시작된다.
3. **지연 평가**: 스트림은 중간 연산이 호출되더라도 실제로 데이터 처리는 최종 연산이 호출될 때까지 지연된다. 이는 성능 최적화에 도움이 된다.
4. **병렬 처리**: 스트림 API는 손쉽게 병렬 처리를 지원하여, 멀티코어 프로세서를 활용할 수 있다.

</details>

<br>

<details>
<summary style="font-size: 1.5em; font-weight: bold;">Java Lambda 표현식이란?</summary>

### 람다(Lambda) vs 람다 표현식(Lambda Expression)
- **람다(Lambda)**:
  - 일반적으로 익명 함수(Anonymous Function)를 지칭하는 포괄적인 개념이다.
  - 자바에서의 람다 표현식은 이러한 람다의 개념을 코드로 구현한 것이다.
- **람다 표현식(Lambda Expression)**:
  - 자바에서 람다 함수의 구체적인 문법으로, 함수형 인터페이스를 구현하는 방법이다. (parameters -> expression 형식으로 작성된다.)
  - 자바에서 람다 표현식을 사용하여 코드의 가독성을 높이고, 익명 클래스를 대체한다.

</details>

<br>

<details>
<summary style="font-size: 1.5em; font-weight: bold;">Reflection 이란?</summary>

### Reflection의 주요 개념
Java에서 `Reflection`은 프로그램 실행 중에 클래스, 메서드, 필드 등의 정보를 동적으로 조사하고 조작할 수 있는 기능을 제공한다. 이 기능은 Java의 `java.lang.reflect` 패키지를 통해 제공된다.

1. **클래스 정보 조회**:
   - `Reflection`을 사용하면 클래스의 이름, 메서드, 필드, 생성자 등 다양한 정보를 동적으로 조회할 수 있다.
   - 예를 들어, 클래스를 사용하여 해당 클래스의 메서드 목록을 가져오거나 특정 메서드의 접근 제어자(공개, 비공개 등)를 확인할 수 있다.
2. **객체 생성**:
   - `Reflection`을 통해 클래스의 인스턴스를 동적으로 생성할 수 있다.
   - 예를 들어, 클래스의 이름만 알고 있을 때 해당 클래스의 객체를 생성할 수 있다.
3. **메서드 호출**:
   - `Reflection`을 사용하면 객체의 메서드를 동적으로 호출할 수 있다.
   - 이는 컴파일 타임에 메서드 이름이 정해지지 않았거나, 메서드 이름이 런타임에 결정되는 경우에 유용하다.
4. **필드 접근**:
   - `Reflection`을 통해 객체의 필드에 접근하고, 값을 읽거나 수정할 수 있다. 이는 필드가 private일 경우에도 가능하다.

### Reflection의 사용 용도
1. **프레임워크 및 라이브러리**:
   - 많은 Java 프레임워크(예로 Spring, Hibernate)는 `Reflection`을 사용하여 객체의 메타데이터를 처리하고, 의존성 주입 및 ORM(Object-Relational Mapping) 등을 구현한다.
2. **동적 프로그래밍**:
   - 런타임에 클래스와 메서드를 동적으로 조작해야 하는 경우에 유용하다. 예를 들어, 플러그인 시스템이나 스크립트 언어와의 통합에서 자주 사용된다.
3. **테스트 및 디버깅**:
   - `Reflection`을 사용하면 테스트 프레임워크가 private 필드나 메서드에 접근하여 테스트할 수 있도록 도와준다.

### 주의 사항
> - **성능**: `Reflection`은 일반적인 코드에 비해 성능이 떨어질 수 있다. 동적으로 메서드나 필드에 접근하는 과정에서 오버헤드가 발생할 수 있다.
> - **보안**: `Reflection`을 사용하면 private 필드나 메서드에 접근할 수 있으므로, 보상의 위험이 있을 수 있다.
> - **유지보수**: `Reflection`을 사용한 코드는 가독성이 떨어질 수 있어, 코드의 유지보수가 어려워질 수 있다.

</details>

---

## 3. Java의 컬렉션 프레임워크

<details>
<summary style="font-size: 1.5em; font-weight: bold;">List, Set, Map 인터페이스</summary>

<br>

<details>
<summary style="font-size: 1.3em; font-weight: bold;">List 인터페이스란?</summary>

### List 인터페이스란?
자바에서 `List` 인터페이스는 컬렉션 프레임워크의 일부로, 순서가 있는 요소의 집합을 나타낸다. `List`는 중복된 요소를 허용하며, 요소의 순서를 유지한다.
자바에서는 `List` 인터페이스를 구현한 여러 클래스가 있으며, 가장 일반적으로 사용되는 두 가지는 `ArrayList`와 `LinkedList`이다.

### List 인터페이스의 주요 특징
1. **순서 유지**:
    - `List`에 추가된 요소는 삽입된 순서를 유지한다. 즉, 요소에 접근할 때 인덱스를 사용하여 특정 위치의 요소에 쉽게 접근할 수 있다.
2. **중복 허용**:
    - `List`는 동일한 요소를 여러 번 추가할 수 있으므로 중복된 값이 허용된다.
3. **인덱스 기반 접근**:
    - `List`는 인덱스를 사용하여 요소에 접근할 수 있다.
    - 예를 들어, `get(int index)` 메서드를 사용하여 특정 인덱스의 요소를 가져올 수 있다.

#### 주요 메서드
- **`add(E e)`**: 리스트의 끝에 요소를 추가한다.
- **`add(int index, E element)`**: 지정된 인덱스에 요소를 추가한다.
- **`get(int index)`**: 지정된 인덱스의 요소를 반환한다.
- **`remove(int index)`**: 지정된 인덱스의 요소를 제거한다.
- **`set(int index, E element)`**: 지정된 인덱스의 요소를 새 요소로 교체한다.
- **`size( )`**: 리스트의 요소 개수를 반환한다.
- **`isEmpty( )`**: 리스트가 비어 있는지 확인한다.
- **`indexOf(Object o)`**: 지정된 요소의 인덱스를 반환한다.

</details>

<br>

<details>
<summary style="font-size: 1.3em; font-weight: bold;">Set 인터페이스란?</summary>

### Set 인터페이스란?
자바에서 `Set` 인터페이스는 컬렉션 프레임워크의 일부로, 중복된 요소를 허용하지 않는 집합을 나타낸다. `Set`은 순서가 없으며, 특정 요소의 존재 여부를 확인하거나, 요소를 추가 및 삭제하는 데 사용된다.
`Set` 인터페이스를 구현한 주요 클래스는 `HashSet`, `LinkedHashSet`, `TreeSet` 등이 있다.

### Set 인터페이스의 주요 특징
1. **중복 요소 허용 안 함**:
    - `Set`은 동일한 값을 여러 번 추가할 수 없다. 따라서 이미 존재하는 요소를 추가하면 추가가 무시된다.
2. **순서 없음**:
    - `Set`은 요소의 순서를 유지하지 않기 때문에, 요소가 저장된 순서와는 상관없이 요소에 접근해야 한다.
    - 하지만 `LinkedHashSet`과 `TreeSet`은 각각 삽입 순서와 정렬된 순서를 유지한다.
3. **효율적인 검색**:
    - `Set`은 요소의 존재 여부를 빠르게 확인할 수 있도록 설계되었다.
    - 특히, `HashSet`은 해시 테이블을 기반으로 하여 검색 성능이 뛰어나다.

#### 주요 메서드
- **`add(E e)`**: 집합에 요소를 추가한다. 이미 존재하는 요소라면 추가하지 않는다.
- **`remove(Object o)`**: 지정된 요소를 집합에서 제거한다.
- **`contains(Object o)`**: 지정된 요소가 집합에 포함되어 있는지 확인한다.
- **`size( )`**: 집합의 요소 개수를 반환한다.
- **`isEmpty( )`**: 집합이 비어 있는지 확인한다.
- **`clear( )`**: 집합의 모든 요소를 제거한다.

</details>

<br>

<details>
<summary style="font-size: 1.3em; font-weight: bold;">Map 인터페이스란?</summary>

### Map 인터페이스란?
자바에서 `Map` 인터페이스는 키-값 쌍으로 데이터를 저장하는 컬렉션을 나타낸다. `Map`은 각 키가 고유하며, 동일한 키에 대해 하나의 값만을 가질 수 있다.
`Map` 인터페이스의 주요 구현 클래스는 `HashMap`, `LinkedHashMap`, `TreeMap` 등이 있다.

### Map 인터페이스의 주요 특징
1. **키-값 쌍**:
   - `Map`은 각 요소가 키와 값으로 구성된 쌍으로 저장된다. 키를 사용하여 값을 검색할 수 있다.
2. **고유한 키**: 
    - `Map`의 각 키는 고유해야 하며, 동일한 키를 사용하여 값을 추가하면 기존의 값이 새로운 값으로 덮어씌워진다.
3. **순서**: 
   - 기본적으로 `HashMap`은 순서를 보장하지 않지만, `LinkedHashMap`은 삽입 순서를 유지하고, `TreeMap`은 키의 자연 순서 또는 지정된 `Comparator`에 따라 정렬된 순서를 유지한다.

#### 주요 메서드
- **`put(K key, V value)`**: 주어진 키에 대해 값을 추가하거나 기존 값을 대체한다.
- **`get(Object key)`**: 주어진 키에 대한 값을 반환하고, 키가 존재하지 않으면 `Null`을 반환한다.
- **`remove(Object key)`**: 주어진 키와 관련된 값을 제거한다.
- **`containsKey(Object key)`**: 주어진 키가 `Map`에 존재하는지 확인한다.
- **`containsValue(Object value)`**: 주어진 값이 `Map`에 존재하는지 확인한다.
- **`size( )`**: `Map`의 키-값 쌍의 개수를 반환한다.
- **`isEmpty( )`**: `Map`이 비어 있는지 확인한다.
- **`clear( )`**: `Map`의 모든 키-값 쌍을 제거한다.
- **`keySet( )`**: `Map`의 모든 키를 반환하는 `Set`을 반환한다.
- **`values( )`**: `Map`의 모든 값을 반환하는 `Collection`을 반환한다.
- **`entrySet( )`**: `Map`의 모든 키-값 쌍을 포함하는 `Set`을 반환한다.

</details>
</details>

<br>

<details>
<summary style="font-size: 1.5em; font-weight: bold;">ArrayList, HashSet, HashMap 구현체</summary>

### 

</details>

<br>

<details>
<summary style="font-size: 1.5em; font-weight: bold;">Iterator 사용법</summary>

### Iterator 란?
자바에서 `Iterator`는 컬렉션 객체에 포함된 요소를 순차적으로 접근하고 처리할 수 있는 방법을 제공한다.
`Iterator`를 사용하면 컬렉션의 요소를 안전하게 반복(iterate)할 수 있으며, 컬렉션의 구조를 변경하지 않고도 요소를 제거할 수 있다.

### Iterator 인터페이스란?
`Iterator`는 `java.util` 패키지에 정의된 인터페이스로, 다음과 같은 주요 메서드를 제공한다: 
- **`boolean hasNext( )`**: 다음 요소가 존재하는지 여부를 반환한다.
- **`E next( )`**: 다음 요소를 반환하고, 커서를 다음 위치로 이동한다.
- **`void remove( )`**: 마지막으로 반환된 요소를 컬렉션에서 제거한다. 이 메서드는 선택적이며, 호출하기 전에 반드시 `next( )`를 호출해야 한다.

### Iterator 사용법
#### a. Iterator 생성
`Iterator`는 `Collection` 인터페이스를 구현한 클래스에서 `iterator( )` 메서드를 통해 생성할 수 있다.
예를 들어, `ArrayList`, `HashSet`, `LinkedList` 등에서 사용할 수 있다.

#### b. Iterator 예제
아래는 `ArrayList`에서 `Iterator`를 사용하는 예제이다:

```java
import java.util.ArrayList;
import java.util.Iterator;

public class Example {
    public static void main(String[] args) {
        // ArrayList 생성 및 요소 추가
        ArrayList<String> fruits = new ArrayList<>();
        fruits.add("Apple");
        fruits.add("Banana");
        fruits.add("Cherry");
        
        // Iterator 생성
        Iterator<String> iterator = fruits.iterator();

        // Iterator를 사용하여 요소 반복
        while (iterator.hasNext()) {
            String fruit = iterator.next();
            System.out.println(fruit);
        }
    }
}
```

### 요소 제거
`Iterator`를 사용하면 컬렉션의 요소를 안전하게 제거할 수 있다. `remove( )` 메서드는 `next( )` 메서드로 반환된 마지막 요소를 제거한다.

```java
import java.util.ArrayList;
import java.util.Iterator;

public class Example {
    public static void main(String[] args) {
        // ArrayList 생성 및 요소 추가
        ArrayList<String> fruits = new ArrayList<>();
        fruits.add("Apple");
        fruits.add("Banana");
        fruits.add("Cherry");

        // Iterator 생성
        Iterator<String> iterator = fruits.iterator();

        // 특정 요소 제거 예제
        while (iterator.hasNext()) {
            String fruit = iterator.next();
            if (fruit.equals("Banana")) {
                iterator.remove(); // "Banana" 요소 제거
            }
        }

        // 결과 출력
        System.out.println(fruits); // 출력: [Apple, Cherry]
    }
}
```

### Iterator의 장점
- **안전한 요소 제거**:
  - `Iterator`를 사용하면 반복 중에 요소를 안전하게 제거할 수 있다.
  - 일반적인 `for-each` 루프에서 요소를 제거하면 `ConcurrentModificationException`이 발생할 수 있지만, `Iterator`를 사용하면 이러한 문제를 피할 수 있다.
- **일관된 접근**:
  - `Iterator`는 컬렉션의 구조가 변경되지 않는 한, 요소에 일관되게 접근할 수 있도록 보장한다.

</details>

---

## 4. Java의 예외 처리

<details>
<summary style="font-size: 1.5em; font-weight: bold;">Exception의 종류(Checked, Unchecked)</summary>

### Checked Exception
`Checked Exception`은 컴파일 타임에 검사되는 예외이다. 즉, 이러한 예외가 발생할 가능성이 있는 코드에서는 반드시 예외 처리를 해야 한다. 그렇지 않으면 컴파일 에러가 발생한다.

- `Checked Exception`은 `Exception` 클래스의 하위 클래스 중에서 `RuntimeException`이 아닌 클래스이다.
- 예외 처리를 강제하기 때문에, 개발자가 프로그램의 안정성을 높일 수 있다.
- 예를 들어, `IOException`, `SQLException`, `ClassNotFoundException` 등 외부 시스템과의 상호작용에서 발생할 수 있는 예외가 포함된다.

#### 예외 처리 방법
`Checked Exception`은 `try-catch` 블록으로 처리하거나, 메서드 선언에 `throws` 키워드를 사용하여 호출하는 쪽에서 처리하도록 할 수 있다.

```java
import java.io.*;

public class CheckedExceptionExample {
    public static void main(String[] args) {
        try {
            FileInputStream file = new FileInputStream("file.txt");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

### Unchecked Exception
`Unchecked Exception`은 런타임에 발생하는 예외로, 컴파일 타임에 검사되지 않는다. 이러한 예외는 주로 프로그래밍 오류로 인해 발생한다.

- `Unchecked Exception`은 `RuntimeException` 클래스의 하위 클래스이다.
- 개발자가 예외 처리를 하지 않아도 컴파일 에러가 발생하지 않는다. 그러나 런타임에서 예외가 발생할 수 있다.
- 예외 처리가 강제되지 않기 때문에, 프로그램의 실행 중에 예기치 않은 상황을 유발할 수 있다.
- 예를 들어, `NullPointException`, `ArrayIndexOutOfBoundException`, `ArithmeticException` 등이 있다.

#### 예외 처리 방법
`Unchecked Exception`은 선택적으로 `try-catch` 블록으로 처리할 수 있다.

```java
public class UncheckedExceptionExample {
    public static void main(String[] args) {
        int[] numbers = {1, 2, 3};
        try {
            System.out.println(numbers[3]); // ArrayIndexOutOfBoundsException 발생
        } catch (ArrayIndexOutOfBoundsException e) {
            e.printStackTrace();
        }
    }
}
```

</details>

<br>

<details>
<summary style="font-size: 1.5em; font-weight: bold;">try-catch-finally 블록</summary>

### try-catch-finally 블록이란?
자바에서 `try-catch-finally` 블록은 예외 처리를 위한 구조로, 프로그램 실행 중 발생할 수 있는 예외를 처리하고, 예외 발생 여부에 관계없이 특정 코드를 실행할 수 있도록 한다.
이를 통해 프로그램의 안정성을 높이고, 오류 발생 시 적절한 대응을 할 수 있다.

#### 기본 구조
```java
try {
    // 예외가 발생할 수 있는 코드
} catch (ExceptionType e) {
    // 예외 발생 시 실행할 코드
} finally {
    // 항상 실행되는 코드
}
```

#### 각 블록의 역할
- **`try` 블록**: 
  - 예외가 발생할 가능성이 있는 코드를 포함한다.
  - 이 블록 내에서 예외가 발생하면, 해당 예외는 `catch` 블록으로 전달된다.
- **`catch` 블록**: 
  - `try` 블록에서 발생한 예외를 처리하는 코드이다.
  - 여러 개의 `catch` 블록을 사용할 수 있으며, 각 블록은 특정 예외 유형을 처리하도록 구성할 수 있다.
  - 예외 객체를 통해 발생한 예외에 대한 정보에 접근할 수 있다.
- **`finally` 블록**: 
  - 예외 발생 여부에 관계없이 항상 실행되는 코드이다.
  - 주로 리소스 해제, 파일 닫기, 데이터베이스 연결 종료 등의 작업에 사용된다.
  - `finally` 블록은 `try-catch` 블록이 종료된 후에 항상 실행된다.

</details>

<br>

<details>
<summary style="font-size: 1.5em; font-weight: bold;">사용자 정의 예외</summary>

### 사용자 정의 예외 클래스 생성
자바에서 사용자 정의 예외는 개발자가 필요에 따라 직접 정의한 예외 클래스이다. 기본 제공되는 예외 클래스 외에도 특정 상황에 맞는 예외를 만들고 싶을 때 사용자 정의 예외를 사용한다.
이를 통해 코드의 가독성을 높이고, 예외 처리를 보다 명확하게 할 수 있다.

사용자 정의 예외는 `Exception` 클래스(또는 `RuntimeException` 클래스)를 상속하여 만들 수 있다. 일반적으로 체크 예외를 만들고 싶다면 `Exception`을 상속하고, 런타임 예외를 만들고 싶다면 `RuntimeException`을 상속한다.

### 사용자 정의 예외 클래스 예시
```java
// 사용자 정의 체크 예외 클래스
class InvalidAgeException extends Exception {
    public InvalidAgeException(String message) {
        super(message); // 부모 클래스의 생성자 호출
    }
}

// 사용자 정의 예외를 사용하는 클래스
public class Example {
    public static void validateAge(int age) throws InvalidAgeException {
        if (age < 18) {
            throw new InvalidAgeException("나이는 18세 이상이어야 합니다.");
        }
        System.out.println("유효한 나이입니다: " + age);
    }

    public static void main(String[] args) {
        try {
            validateAge(15); // 예외 발생
        } catch (InvalidAgeException e) {
            System.out.println("예외 발생: " + e.getMessage());
        }
    }
}
```

1. **사용자 정의 예외 클래스**:
    - `InvalidAgeException` 클래스는 `Exception`을 상속받아 생성된다. 생성자에서 메시지를 받아 부모 클래스의 생성자를 호출하여 예외 메시지를 설정한다.
2. **예외 발생 메서드**:
    - `validateAge` 메서드는 나이를 검사하고, 만약 나이가 18세 미만이면 `InvalidAgeException`을 발생시킨다.
    - 이 메서드는 체크 예외이므로, `throws InvalidAgeException`을 사용하여 예외가 발생할 수 있음을 선언한다.
3. **예외 처리**:
    - `main` 메서드에서 `validateAge(15)`를 호출하면 예외가 발생하고, 이를 `try-catch` 블록으로 처리하여 예외 메시지를 출력한다.

### 사용자 정의 예외 사용 시 장점
- **명확한 코드 표현**: 
  - 특정 상황에 맞는 예외를 정의함으로써 코드의 가독성을 높이고, 예외 상황을 명확하게 표현할 수 있다.
- **유지보수 용이**:
  - 특정 비즈니스 로직에 맞는 예외를 사용하면, 코드 변경 시 예외 처리 로직을 일괄적으로 수정하기 쉬워진다.
- **구체적인 예외 처리**:
  - 다양한 상황에 대해 구체적인 예외를 만들고 처리할 수 있으므로, 보다 세밀한 예외 처리가 가능하다.

</details>

---

## 5. 멀티스레딩

<details>
<summary style="font-size: 1.5em; font-weight: bold;">스레드의 개념</summary>

### 스레드란?
스레드는 프로세스 내에서 실행되는 단위로, 프로세스는 하나 이상의 스레드를 포함할 수 있다. 각 스레드는 독립적으로 실행되며, 자신의 스택과 프로그램 카운터를 가진다.
- 자바에서는 JVM에 의해 관리가 되며, 스레드가 1개면 단일 스레드, 2개 이상이면 멀티 스레드 환경이 된다.

#### 💡 프로세스란?
> 프로세스(Process)는 CPU에 의해 메모리에 올라가서 실행 중인 프로그램을 의미한다. 프로세스는 자신만의 메모리 공간을 포함한 독립적인 실행 공간을 가지고 있다.
> JVM은 주로 하나의 프로세스로 실행되며, 동시에 여러 작업을 수행하기 위해 멀티 스레드를 지원한다.

### 스레드를 사용하는 이유
1. **효율적인 자원 활용**: 
   - 현대의 컴퓨터는 멀티코어 CPU를 갖추고 있어, 여러 스레드가 동시에 실행될 수 있다. 이를 통해 CPU 자원을 효율적으로 활용할 수 있다.
   - 스레드를 사용하면 여러 작업을 병렬로 처리하여 성능을 극대화할 수 있다.
2. **응답성 향상**:
   - 사용자 인터페이스(UI)를 가진 애플리케이션에서는 스레드를 사용하여 장시간 걸리는 작업(예를 들어, 파일 다운로드, 데이터베이스 쿼리 등)을 백그라운드에서 수행할 수 있다.
   - 이로 인해 UI가 차단되지 않고 사용자에게 즉각적인 반응을 제공할 수 있다.
3. **비동기 처리**:
   - 네트워크 요청이나 I/O 작업과 같은 비동기 작업을 처리할 때 스레드를 사용하면, 메인 스레드가 이러한 작업을 기다리지 않고 다른 작업을 계속 수행할 수 있다.
   - 이는 전체 프로그램의 대기 시간을 줄이는 데 도움을 준다.
4. **코드의 구조적 정리**:
   - 멀티스레딩을 사용하면 각 스레드가 특정 작업을 수행하도록 설계할 수 있어, 코드의 구조가 더욱 명확해진다.
   - 각 스레드는 독립적으로 작업을 수행하므로, 코드의 모듈화가 쉬워진다.

### 스레드의 상태
- **새로운 상태 (NEW)**: 스레드가 생성되었지만, 아직 실행되지 않은 상태.
- **실행 중 (RUNNABLE)**: 실행 가능한 상태로, CPU의 할당을 기다리는 상태.
- **대기 상태 (BLOCKED)**: 다른 스레드에 의해 실행이 차단된 상태.
- **기다림 (WAITING)**: 특정 조건이 충족될 때까지 대기하는 상태.
- **종료 상태 (TERMINATED)**: 실행이 완료되어 종료된 상태.

</details>

<br>

<details>
<summary style="font-size: 1.5em; font-weight: bold;">Runnable 인터페이스와 Thread 클래스</summary>

### Runnable 인터페이스와 Thread 클래스란?
자바에서 스레드를 생성하고 실행하는 방법에는 두 가지 주요 접근 방식이 있다: `Runnable` 인터페이스를 구현하는 방법과 `Thread` 클래스를 상속하는 방법이다.

#### 1. Runnable 인터페이스
`Runnable` 인터페이스는 스레드가 수행할 작업을 정의하는 메서드인 `run( )`을 포함한다. 이 인터페이스를 구현하면, 스레드의 작업 내용을 별도의 클래스에 정의할 수 있다.

1. `Runnable` 인터페이스를 구현한 클래스를 생성한다.
2. `run( )` 메서드에 스레드에서 수행할 작업을 정의한다.
3. `Thread` 객체를 생성하고, 생성자에 `Runnable` 객체를 전달한다.
4. `start( )` 메서드를 호출하여 스레드를 실행한다.

```java
class MyRunnable implements Runnable {
    @Override
    public void run() {
        System.out.println("스레드 실행 중");
    }
}

public class Main {
    public static void main(String[] args) {
        MyRunnable myRunnable = new MyRunnable();
        Thread thread = new Thread(myRunnable);
        thread.start(); // 스레드 시작
    }
}
```

#### 2. Thread 클래스
`Thread` 클래스는 자바에서 스레드를 생성하고 실행하는 클래스이다. 이 클래스를 상속하여 직접 스레드를 정의할 수 있다.

1. `Thread` 클래스를 상속하여 새로운 클래스를 생성한다.
2. `run( )` 메서드를 오버라이드하여 스레드에서 수행할 작업을 정의한다.
3. `start( )` 메서드를 호출하여 스레드를 실행한다.

```java
class MyThread extends Thread {
    @Override
    public void run() {
        System.out.println("스레드 실행 중");
    }
}

public class Main {
    public static void main(String[] args) {
        MyThread thread = new MyThread();
        thread.start(); // 스레드 시작
    }
}
```

보통 `Runnable` 인터페이스를 구현하는 방법으로 많이 생성하여 사용하는 데, 그 이유는 `Thread` 클래스를 extends 해버리면, 다른 클래스를 더 이상 상속할 수 없기 때문이다.
> 단, `Runnable`을 구현하여 스레드를 생성하는 경우, **객체 참조 변수를 인자값으로 하는 `Thread`를 생성하여 사용**해야 한다.
> 반면, `java.lang.Thread` 클래스를 상속받아 사용하는 경우, **실행 스레드로 자신의 콜 스택을 가진 독립적인 프로세스**가 된다.

</details>

<br>

<details>
<summary style="font-size: 1.5em; font-weight: bold;">동기화 및 Lock</summary>

자바에서 `동기화(Synchronization)`와 `Lock`은 멀티스레드 프로그래밍에서 여러 스레드가 동시에 공유 자원에 접근할 때 발생할 수 있는 문제를 해결하기 위한 기법이다.
이러한 기법들은 데이터의 일관성과 무결성을 유지하는 데 중요한 역할을 한다.

### 동기화 (Synchronization) 란?
동기화는 여러 스레드가 동일한 자원에 동시에 접근하지 못하도록 제어하는 방법이다. 자바에서는 `synchronized` 키워드를 사용하여 동기화를 구현할 수 있다.

#### a. 동기화 메서드
동기화 메서드는 메서드 선언에 `synchronized` 키워드를 붙여서 정의한다. 이렇게 하면 해당 메서드에 대한 접근은 한 번에 하나의 스레드만 가능하게 된다.
```java
public synchronized void synchronizedMethod() {
    // 동기화된 코드 블록
}
```

#### b. 동기화 블록
동기화 블록은 특정 코드 블록에 대해서만 동기화를 적용할 수 있다. 이는 성능을 개선할 수 있는 방법이다.
```java
public void method() {
    synchronized (this) {
        // 동기화된 코드 블록
    }
}
```

### Lock 이란?

</details>

---

## 6. Java 메모리 관리

<details>
<summary style="font-size: 1.5em; font-weight: bold;">가비지 컬렉션(Garbage Collection)</summary>

### 

</details>

<br>

<details>
<summary style="font-size: 1.5em; font-weight: bold;">Heap과 Stack 메모리 구조</summary>

### 

</details>

---

## 7. JVM, JRE, JDK

<details>
<summary style="font-size: 1.5em; font-weight: bold;">JVM의 역할</summary>

### JVM이란?
JVM은 Java Virtual Machine의 줄임말로, 직역하면 '자바를 실행하기 위한 가상 기계(컴퓨터)'라고 할 수 있다.

Java는 OS(운영체제)에 종속적이지 않다는 특징을 가지고 있는데, OS에 종속받지 않고 실행되기 위해선 OS 위에서 Java를 실행시킬 무언가가 필요한데, 그게 바로 JVM이다.
> 즉, OS에 종속받지 않고 CPU가 Java를 인식하고 실행할 수 있게 하는 가상 컴퓨터이다.

#### 컴파일 과정
자바의 소스코드 즉, 원시코드(`*.java`)는 CPU가 인식을 하지 못하므로 기계어로 컴파일을 해줘야 한다.
하지만, Java는 JVM이라는 가상머신을 거쳐서 OS에 도달하기 때문에 OS가 인식할 수 있는 기계어로 바로 컴파일되는 게 아닌 JVM이 인식할 수 있는 자바 바이트코드(`*.class`)로 변환된다.

> 즉, 자바 컴파일러(Java Compiler)가 `.java` 파일을 `.class` 라는 자바 바이트코드로 변환한다.

#### 💡 자바 컴파일러(Java Compiler) 란?
> 자바 컴파일러는 JDK를 설치하면 `bin`에 존재하는 `javac.exe`를 의미한다.
> 즉, JDK에 자바 컴파일러가 포함되어 있다는 의미로, `javac` 명령어를 통해 `.java`를 `.class`로 컴파일할 수 있다.

변환된 바이트코드는 기계어가 아니기 때문에, OS에서 바로 실행되지 않는다. 이때, JVM이 OS가 바이트코드를 이해할 수 있도록 해석해준다. 따라서 바이트코드는 JVM 위에서 OS와 상관없이 실행될 수 있게 된다.
때문에, OS에 종속적이지 않고, 자바 파일 하나만 만들면 어느 디바이스든 JVM 위에서 실행할 수 있다.

### 바이트코드란?
자바 바이트코드는 JVM이 이해할 수 있는 언어로 변환된 자바 소스코드를 의미한다. 즉, 가상 컴퓨터에서 돌아가는 실행 프로그램을 위한 이진 표현법이다.
- 바이트코드라고 하는 이유는 자바 컴파일러에 의해 변환된 코드의 명령어 크기가 1Byte라서 자바 바이트코드라고 불린다.

이후 바이트코드는 다시 실시간 번역기 또는 JIT 컴파일러에 의해 바이너리 코드로 변환된다.

#### 💡 바이너리 코드란?
> 바이너리 코드 또는 이진 코드라고도 하며, 컴퓨터가 인식할 수 있는 0과 1로 구성된 이진코드이다.

#### 💡기계어란?
> 0과 1로 이루어진 바이너리 코드로, 기계어가 이진코드로 이루어졌을 뿐 모든 이진코드가 기계어인 것은 아니다.
> 기계어는 특정한 언어가 아니라 CPU가 이해하는 명령어 집합이며, CPU 제조사마다 기계어가 다를 수 있다.

즉, CPU가 이해하는 언어는 `바이너리 코드`, 가상 머신이 이해하는 코드는 `바이트 코드`이다.

### JIT 컴파일러의 개념 및 동작 방식
#### JIT 컴파일러의 기본 개념
JIT 컴파일(Just-In-Time Compliation) 또는 동적 번역(Dynamic Translation)이라고 한다.
> JIT 컴파일러는 프로그램을 실제 실행하는 시점에 기계어로 변역하는 컴파일러이다.

JIT 컴파일러는 인터프리터 방식의 단점을 보완하기 위해 도입되었다.
> 인터프리터 방식으로 실행하다가 적절한 시점에 바이트 코드 전체를 컴파일하여 기계어로 변경하고, 
> 이후에는 더 이상 인터프리팅하지 않고 기계어로 직접 실행하는 방식이다.

기계어(컴파일된 코드)는 캐시에 보관하기 때문에 한 번 컴파일된 코드는 빠르게 수행하게 된다. 
물론, JIT 컴파일러가 컴파일하는 과정은 바이트코드를 인터프리팅하는 것보다 훨씬 오래걸리므로 한 번만 실행되는 코드라면 컴파일하지 않고 인터프리팅하는 것이 유리하다.
따라서, JIT 컴파일러를 사용하는 JVM은 내부적으로 해당 메서드가 얼마나 자주 수행되는지 체크하고 일정 정도를 넣을 때에만 컴파일을 수행한다.

#### JIT 컴파일러의 동작 방식
자바에서 자바 컴파일러가 자바 프로그램 코드를 바이트코드로 변환한 다음, 실제 바이트코드를 실행하는 시점에서 JRE이 바이트코드를 JIT 컴파일을 통해 기계어로 변환한다.

### JVM의 구성요소
JVM은 크게 클래스 로더, 실행 엔진, 런타임 데이터 영역으로 나누어진다.

#### 클래스 로더란?
JVM 내부에 있는 클래스 파일(`*.class`)을 로드하고, 링크를 통해 배치하는 작업을 수행하는 모듈이다. 런타임 시 동적으로 클래스를 로드하고 `jar` 파일 내 저장된 클래스들을 JVM 위에 탑재한다.
> 즉, 클래스를 처음으로 참조할 때, 해당 클래스를 로드하고 링크하는 역할을 한다.

#### 실행 엔진이란?
클래스를 실행시키는 역할로, 클래스 로더가 JVM 내부에 있는 런타임 데이터 영역에 바이트코드를 배치시키고 이를 실행 엔진이 실행한다.
> 자바 바이트코드(`*.class`)는 기계가 바로 수행할 수 있는 언어보다는 비교적 인간이 보기 편한 형태로 기술된 것이다.
> 그래서 실행 엔진은 이와 같은 바이트코드를 실제로 JVM 내부에서 기계가 실행할 수 있는 형태로 변경한다.

<details>
<summary style="font-size: 1.1em; font-weight: bold;">실행 엔진의 구성요소</summary>

##### 인터프리터란?
실행 엔진은 자바 바이트코드를 명령어 단위로 읽어서 실행한다. 하지만 한 줄씩 수행하기 때문에 느리다는 단점이 있다.

##### JIT 컴파일러란?
인터프리티 방식으로 실행하다가 적절한 시점에 바이트코드 전체를 컴파일하여 기계어로 변환하고, 이후 더 이상 인터프리팅하지 않고 기계어로 직접 실행하는 방식이다.

##### 가비지 콜렉터란?
더 이상 사용되지 않는 인스턴스를 찾아 메모리에서 삭제하는 역할을 한다.

</details>

#### 런타임 데이터 영역이란?
런타임 데이터 영역은 프로그램을 수행하기 위해 OS에서 할당받은 메모리 공간이다.

<details>
<summary style="font-size: 1.1em; font-weight: bold;">런타임 데이터 영역의 구성요소</summary>

##### PC Register란?
스레드가 시작될 때 생성되며, 생성될 때마다 생성되는 공간으로 스레드마다 하나씩 존재한다.
스레드가 어떤 부분을 어떤 명령으로 실행해야 할 지 기록하는 부분으로 현재 수행 중인 JVM 명령의 주소를 갖는다.

##### JVM 스택 영역
> 프로그램 실행과정에서 임시로 할당되었다가 메서드를 빠져나가면 바로 소멸되는 특성의 데이터를 저장하기 위한 영역이다.

각종 형태의 변수나 임시 데이터, 스레드나 메서드의 정보를 저장한다. 메서드 호출 시마다 각각의 스택 프레임(해당 메서드만을 위한 공간)이 생성된다.
메서드 수행이 끝나면 프레임 별로 삭제하고, 메서드 안에서 사용되는 값들을 저장한다. 또한, 호출된 메서드의 매개변수, 지역변수, 리턴값 및 연산 시 일어나는 값들을 임시로 저장한다. 

##### Native Method Stack
> 자바 프로그램이 컴파일되어 생성되는 바이트코드가 아닌 실제 실행할 수 있는 기계어로 작성된 프로그램을 실행시키는 영역이다.

자바가 아닌 다른 언어로 작성된 코드를 위한 공간으로, Java Native Interface를 통해 바이트코드로 전환하여 저장하게 된다.
일반 프로그램처럼 커널이 스택을 잡아 독자적으로 프로그램을 실행시키는 영역이다.

##### Method Area(Class Area, Static Area)
> 클래스 정보를 처음으로 메모리 공간에 올릴 때 초기화되는 대상을 저장하기 위한 메모리 공간이다.

Runtime Constant Pool은 이러한 Static 영역에 존재하는 별도의 관리 영역으로, 상수 자료형을 저장하여 참조하고 중복을 막는 역할을 수행한다.

##### Heap 영역
객체를 저장하는 가상 메모리 공간으로, `new` 연산자로 생성되는 객체와 배열을 저장한다. Class Area(Static Area)에 올라온 클래스들만 객체로 생성이 가능하다.

Heap 영역은 세 부분으로 나누어진다.
- **Permanent Generation**: 
  - 직역하면 영구적인 세대로, 생성된 객체 정보의 주소값이 저장된 공간이다.
  - 클래스 로더에 의해 로드되는 클래스, 메서드 등에 대한 메타 데이터가 저장되는 영역으로 JVM에 의해 사용된다.
  - 또한, Reflection을 사용하여 동적으로 클래스가 로딩되는 경우에도 사용된다.
- **New/Young 영역**:
  - 해당 인스턴스들은 추후 가비지 컬렉터에 의해 사라지며, 생명 주기가 짧은 젊은 객체를 GC의 대상으로 하는 영역으로, 여기서 일어나는 GC를 Minor GC라고도 한다.
  - **Eden**: 객체들이 최초로 생성되는 공간이다.
  - **Survivor 0, 1**: Eden에서 참조되는 객체들이 저장되는 공간이다.
- **Old 영역**:
  - 해당 인스턴스들은 추후 가비지 컬렉터에 의해 사라지며, 생명 주기가 긴 오래된 객체를 GC의 대상으로 하는 영역으로, 여기서 일어하는 GC를 Major GC라고도 한다. (Minor GC에 비해 속도가 느리다.)
  - New/Young 영역에서 일정시간 참조되고 있는 혹은 살아남은 객체들이 저장되는 공간이다.

</details>
</details>

<br>

<details>
<summary style="font-size: 1.5em; font-weight: bold;">JRE와 JDK의 차이점</summary>

### JDK란?
JDK는 Java Development Kit로 직역하면, 자바 개발 키드를 의미한다.
- 즉, 자바를 사용하기 위해 필요한 모든 기능을 갖춘 자바용 SDK(Software Development Kit)이다.
- JDK는 JRE를 포함하며, JRE 외에도 컴파일러(Javac)와 jdb, javadoc과 같은 도구들도 있다.

> 즉, JDK는 프로그램을 생성, 실행, 그리고 컴파일할 수 있다.

### JRE란?
JRE는 Java Runtime Environment로 직역하면, 자바 런타임 환경을 의미한다.
- JRE는 JVM과 자바 클래스 라이브러리 등으로 구성되어 있다.

> 즉, JRE는 컴파일된 자바 프로그램을 실행하는 데 필요한 패키지이다.

#### 💡 SDK란?
> SDK는 Software Development Kit로 직역하면, 소프트웨어 개발 키트이다

</details>

---

## 📨 참고자료
- [객체지향 프로그래밍의 4가지 특징](https://jja2han.tistory.com/330)
- [SOLID 5원칙](https://velog.io/@pp8817/SOLID-%EC%A2%8B%EC%9D%80-%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%EC%84%A4%EA%B3%84%EC%9D%98-5%EA%B0%80%EC%A7%80-%EC%9B%90%EC%B9%99)
- [객체지향 vs 절차지향 vs 함수형 프로그래밍](https://velog.io/@majaeh43/%EC%A0%88%EC%B0%A8%EC%A7%80%ED%96%A5-%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%8D)
- [추상 클래스란?](https://limkydev.tistory.com/188), [인터페이스란?](https://limkydev.tistory.com/197)
- [원시 타입 vs 참조 타입](https://velog.io/@m1naworld/Java-%EC%9B%90%EC%8B%9C-%ED%83%80%EC%9E%85Primitive-Type-VS-%EC%B0%B8%EC%A1%B0-%ED%83%80%EC%9E%85Reference-Type)
- [static 키워드란?](https://mangkyu.tistory.com/47)
- [final 키워드란?](https://sudo-minz.tistory.com/135)

- [Exception의 종류](https://ducktopia.tistory.com/85)

- [스레드란?](https://myeongdev.tistory.com/74)

- [JVM, JDK, JRE란?](https://doozi0316.tistory.com/entry/1%EC%A3%BC%EC%B0%A8-JVM%EC%9D%80-%EB%AC%B4%EC%97%87%EC%9D%B4%EB%A9%B0-%EC%9E%90%EB%B0%94-%EC%BD%94%EB%93%9C%EB%8A%94-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%8B%A4%ED%96%89%ED%95%98%EB%8A%94-%EA%B2%83%EC%9D%B8%EA%B0%80)
